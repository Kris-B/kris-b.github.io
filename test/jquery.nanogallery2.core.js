/**!
 * @preserve nanoGALLERY2 v0.1.0
 * Javascript image gallery by Christophe Brisbois
 * Demo: http://nanogallery2.brisbois.fr
 * Sources: https://github.com/Kris-B/nanoGALLERY2
 *
 * License: For personal, non-profit organizations, or open source projects (without any kind of fee), you may use nanoGALLERY for jQuery for free. 
 * -------- ALL OTHER USES REQUIRE THE PURCHASE OF A PROFESSIONAL LICENSE.
 * 
 * Requirements:
 *  - jQuery (http://www.jquery.com) - version >= 1.7.1
 *
 * Components:
 *  - TinyColor (https://github.com/bgrins/TinyColor) - is embedded
 *  - imagesloaded (https://github.com/desandro/imagesloaded) - is embebed
 *  - screenfull.js (https://github.com/sindresorhus/screenfull.js) - is embeded
 *  - shifty (https://github.com/jeremyckahn/shifty) - is embeded
 *  - webfont generated by http://fontello.com - based on Font Awesome Copyright (C) 2012 by Dave Gandy (http://fortawesome.github.com/Font-Awesome/)
 *  - javascript minifying: grunt-contrib-uglify (https://github.com/gruntjs/grunt-contrib-uglify)
 *  - css minifying: grunt-contrib-cssmin (https://github.com/gruntjs/grunt-contrib-cssmin)
 
 
 
 https://github.com/airbnb/javascript
 
 http://easings.net
 
 
 */


/*

nanoGALLERY2 v0.1.0 release notes.


// changes

- Picasa private albums
Now supports multiple Picasa private albums.
  @old: album -> @new: hiddenAlbums
  album=string | [string]
  example:
    hiddenAlbums: '5851968929721015169&authkey=Gv1sRgCJSlhdKSgoiXtgE'
    hiddenAlbums: ['5851968929721015169&authkey=CJSlhdKSgoiXtgE','6137218671601042145?authkey=CIbGp_iFjfuMkgE'],
  Support '?authkey' and '&authkey'
  Hidden albums will be added to the non-hidded albums (cumulative)

thumbnailLabel
  .titleMultiLine default:false
  .descriptionMultiLine default:false

thumbnailDisplayTransition
  boolean -> string
    'none'
    'fadeIn' 
    'slideUp' (default)
    slideDown, scaleUp, scaleDown
  
// renamed/changed
- API:
    ItemsSetSelectedValue(old: setUnselectedItems and setSelectedItems)
    ItemsSelectedGet(old: getSelectedItems)
    
// no more supported:
- thumbnailLabel.itemsCount = title/description
- i18nTranslations.thumbnailLabelItemsCountPart1  
- i18nTranslations.thumbnailLabelItemsCountPart2  
- API:
    - setSelectMode -> removed, no more needed (only images or albums is defined by the icons defined for images or albums)
    - getSelectMode
  
  
  
**Visit nG2 homepage for usage details: [http://nanogallery2.brisbois.fr](http://www.nanogallery.brisbois.fr/)**

*/

// ###########################################
// ##### nanoGALLERY2 as a JQUERY PLUGIN #####
// ###########################################
;(function ($) {
  "use strict";

  jQuery.nanoGallery2 = function (elt, options) {
    // To avoid scope issues, use '_this' instead of 'this'
    // to reference this class from internal events and functions.
    var _this = this;

    // Access to jQuery and DOM versions of element
    _this.$e = jQuery(elt);
    _this.e = elt;

    // Add a reverse reference to the DOM object
    _this.$e.data('nanoGallery2', _this);

    _this.init = function () {

      // define these global objects only once per HTML page
      if (typeof window.NGY2Item === 'undefined') {

        window.NGY2Tools = (function () {
          function NGY2Tools() {
            var nextId = 1;                   // private static --> all instances
          }

          //+ Jonas Raoni Soares Silva
          //@ http://jsfromhell.com/array/shuffle [v1.0]
          NGY2Tools.AreaShuffle = function (o) {
            for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
            return o;
          }

          // check album name - albumList/blackList/whiteList
          NGY2Tools.FilterAlbumName = function(G, title, ID) {
            var s=title.toUpperCase();

            if( G.albumList !== null ) {
              for( var j=0; j<G.albumList.length; j++) {
                if( s == G.albumList[j].toUpperCase() || ID == G.albumList[j] ) {
                  return true;
                }
              }
            }
            else {
              var found=false;
              if( G.whiteList !== null ) {
                //whiteList : authorize only album cointaining one of the specified keyword in the title
                for( var j=0; j<G.whiteList.length; j++) {
                  if( s.indexOf(G.whiteList[j]) !== -1 ) {
                    found=true;
                  }
                }
                if( !found ) { return false; }
              }


              if( G.blackList !== null ) {
                //blackList : ignore album cointaining one of the specified keyword in the title
                for( var j=0; j<G.blackList.length; j++) {
                  if( s.indexOf(G.blackList[j]) !== -1 ) { 
                    return false;
                  }
                }
              }
              
              return true;
            }
          }            


          /** @function nanoAlert */
          /* Display an alert message in a specific element */
          NGY2Tools.nanoAlert = function(G, msg, verbose) {
            NGY2Tools.nanoConsoleLog(G, msg);
            if( G.$E.conConsole != null ) {
              G.$E.conConsole.css({visibility:'visible', minHeight:'100px'});
              if( verbose == false ) {
                G.$E.conConsole.append('<p>'+ msg + '</p>');
              }
              else {
                G.$E.conConsole.append('<p>nanoGALLERY2: '+msg+ ' ['+G.baseEltID+']</p>');
              }
              //alert('nanoGALLERY: ' + msg);
            }
          };
  
          /** @function nanoConsoleLog */
          /* write message to the browser console */
          NGY2Tools.nanoConsoleLog = function(G, msg) {
            if (window.console) { console.log('nanoGALLERY2: ' + msg + ' ['+G.baseEltID+']'); }
          };

          /** @function PreloaderDisplay() */
          /* Display/hide preloader */
          NGY2Tools.PreloaderDisplay = function(G, display) {
            if( display === true ) {
              G.$E.conLoadingB.removeClass('nanoGalleryLBarOff').addClass('nanoGalleryLBar');
            }
            else {
              G.$E.conLoadingB.removeClass('nanoGalleryLBar').addClass('nanoGalleryLBarOff');
            }
          };
          
          /** @function GetImageTitleFromURL() */
          /* retrieve filemane */
          NGY2Tools.GetImageTitleFromURL = function(G, imageSRC) {
            if( G.O.thumbnailLabel.get('title') == '%filename' ) {
              return (imageSRC.split('/').pop()).replace('_',' ');
            }
            
            if( G.O.thumbnailLabel.get('title') == '%filenameNoExt' ) {
              var s=imageSRC.split('/').pop();
              return (s.split('.').shift()).replace('_',' ');
            }
            return imageSRC;
          };
          

          return NGY2Tools;
        })(); 

        window.NGY2Item = (function() {
        //NGY2Item = (function () {
          var nextId = 1;                   // private static --> all instances

          // constructor
          function NGY2Item( itemID ) {
          //window.NGY2Item = function( itemID ) {
            var ID = 0;                     // private

            // public (this instance only)
            if( itemID === undefined || itemID === null ) {
              ID = nextId++;
            }
            else {
              ID = itemID;
            }
            this.GetID = function () { return ID; };
            
            // public
            this.kind = '';                 // 'image', 'album' or 'albumUp'
            this.title = '';                // image title
            this.description = '';          // image description
            this.albumID = 0;               // ID of the parent album
            this.src = '';                  // full sized image URL
            this.width = 0;                 // image width
            this.height = 0;                // image height
            this.destinationURL = '';       // thumbnail destination URL --> open URL instead of displaying image
            this.author = '';               // image/album author
            this.left=0;                    // store position to animate from old to new
            this.top=0;
            this.width=0;                   // store size to avoid setting width/height if not required
            this.height=0;
            this.resizedContentWidth=0;     // store size of content (image) to avoid setting width/height if not required
            this.resizedContentHeight=0;
            this.thumbs = {                 // URLs and sizes for user defined
              url: { l1 : { xs:'', sm:'', me:'', la:'', xl:'' }, lN : { xs:'', sm:'', me:'', la:'', xl:'' } },
              width: { l1 : { xs:0, sm:0, me:0, la:0, xl:0 }, lN : { xs:0, sm:0, me:0, la:0, xl:0 } },
              height: { l1 : { xs:0, sm:0, me:0, la:0, xl:0 }, lN : { xs:0, sm:0, me:0, la:0, xl:0 } }
            }
            this.featured = false;          // featured element
            this.flickrThumbSizes = {};     // store URLs for all available thumbnail sizes (flickr)
            this.picasaThumbs = null;       // store URLs and sizes
            this.hovered = false;           // is the thumbnail currently hovered?
            this.hoverInitDone = false;
            this.contentIsLoaded = false;   // album: are items already loaded?
            this.contentLength = 0;         // album: number of items (real number of items in memory)
            this.numberItems = 0;           // album: number of items (value returned by data source)
            this.imageNumber = 0;           // image number in the album
            this.eltTransform = {};
            this.paginationLastPage = 0;    // for albums
            this.paginationLastWidth = 0;   // for albums
            this.customData = {};
            this.selected = false;
            this.$elt = null;               // pointer to the corresponding DOM element
            this.$Elts = [];                // cached pointers to the thumbnail content -> to avoid jQuery().find()
          }

          // public static
          
          NGY2Item.Get = function(instance, ID ) {
            var l=instance.I.length;
            for( var i=0; i<l; i++ ) {
              if( instance.I[i].GetID() == ID ) {
                return instance.I[i];
              }
            }
            return null;
          }
            
          NGY2Item.GetIdx = function( instance, ID ) {
            var l=instance.I.length;
            for( var i=0; i<l; i++ ) {
              if( instance.I[i].GetID() == ID ) {
                return i;
              }
            }
            return -1;
          }
          
          NGY2Item.New = function( instance, title, description, ID, albumID, kind ) {
            var album=NGY2Item.Get(instance, albumID);
            if( albumID != -1 && albumID != 0 && title !='dummydummydummy'  ) {
              if( instance.O.thumbnailForNavigation && album.contentLength == 0) {
                // add navigation thumbnail (album up)
                var item=new NGY2Item('0');
                instance.I.push(item);
                album.contentLength+=1;
                item.title='UP';
                item.albumID=albumID;
                item.kind='albumUp';

                jQuery.extend( true, item.thumbs.width, instance.tn.defaultSize.width);
                jQuery.extend( true, item.thumbs.height, instance.tn.defaultSize.height);
                // jQuery.extend( true, item.thumbs.width, instance.tn.settings.width);
                // jQuery.extend( true, item.thumbs.height, instance.tn.settings.height);
              }
            }
            
            var item=NGY2Item.Get(instance, ID);
            if( item === null ){
              item=new NGY2Item(ID);
              instance.I.push(item);
              if( albumID != -1 && title !='dummydummydummy'  ) {
                album.contentLength+=1;
              }
            }

            var kw=instance.O.thumbnailFeaturedKeyword;
            if( kw != '' ) {
              // check if item featured based on a keyword in the title or in the description
              kw=kw.toUpperCase();
              var p=title.toUpperCase().indexOf(kw);
              if( p > -1) {
                item.featured=true;
                // remove keyword case unsensitive
                title=title.substring(0, p) + title.substring(p+kw.length, title.length);
              }
              p=description.toUpperCase().indexOf(kw);
              if( p > -1) {
                item.featured=true;
                // remove keyword case unsensitive
                description=description.substring(0, p) + description.substring(p+kw.length, description.length);
              }
            }
            item.title=title;
            item.description=description;
            item.albumID=albumID;
            item.kind=kind;
            return item;
          }

          NGY2Item.get_nextId = function () {
            return nextId;
          };

          // public (shared across instances)

          // cached sub elements
          NGY2Item.prototype.$getElt = function( elt, forceRefresh ) {
            if( this.$Elts[elt] !== undefined && !forceRefresh == true ) {
              return this.$Elts[elt];
            }
            else {
              this.$Elts[elt]=this.$elt.find(elt);
              return this.$Elts[elt];
            }
          };

          // set thumbnail image real height for current level/resolution, and for all others level/resolutions having the same settings
          NGY2Item.prototype.thumbSetImgHeight = function( instance, h ) {              
            var lst=['xs','sm','me','la','xl'];
            for( var i=0; i< lst.length; i++ ) {
              if( instance.tn.settings.height.l1[lst[i]] == instance.tn.settings.getH() && instance.tn.settings.width.l1[lst[i]] == instance.tn.settings.getW() ) {
                this.thumbs.height.l1[lst[i]]=h;
              }
            }
            for( var i=0; i< lst.length; i++ ) {
              if( instance.tn.settings.height.lN[lst[i]] == instance.tn.settings.getH() && instance.tn.settings.width.l1[lst[i]] == instance.tn.settings.getW() ) {
                this.thumbs.height.lN[lst[i]]=h;
              }
            }
          };

          // set thumbnail image real width for current level/resolution, and for all others level/resolutions having the same settings
          NGY2Item.prototype.thumbSetImgWidth = function( instance, w ) {              
            var lst=['xs','sm','me','la','xl'];
            for( var i=0; i< lst.length; i++ ) {
              if( instance.tn.settings.height.l1[lst[i]] == instance.tn.settings.getH() && instance.tn.settings.width.l1[lst[i]] == instance.tn.settings.getW() ) {
                this.thumbs.width.l1[lst[i]]=w;
              }
            }
            for( var i=0; i< lst.length; i++ ) {
              if( instance.tn.settings.height.lN[lst[i]] == instance.tn.settings.getH() && instance.tn.settings.width.l1[lst[i]] == instance.tn.settings.getW() ) {
                this.thumbs.width.lN[lst[i]]=w;
              }
            }
          };
        
          // Returns Thumbnail image
          NGY2Item.prototype.thumbImg = function ( instance ) {   
            var tnImg = { src:'', width:0, height:0 };

            if( this.title == 'dummydummydummy' ) {
              tnImg.src=instance.emptyGif;
              tnImg.url=instance.emptyGif;
              return tnImg;
            }
            tnImg.src=this.thumbs.url[instance.curNavLevel][instance.curWidth];
            tnImg.width=this.thumbs.width[instance.curNavLevel][instance.curWidth];
            tnImg.height=this.thumbs.height[instance.curNavLevel][instance.curWidth];
            return tnImg;
          };
          
          // for future use...
          NGY2Item.prototype.responsiveURL = function ( instance ) {
            var url = '';
            switch(instance.O.kind) {
              case '':
                url = this.src;
                break;
              case 'flickr':
                url = this.src;
                break;
              case 'picasa':
              default:
                url = this.src;
                break;
            }
            return url;
          };

          return NGY2Item;
        })();    
          
      }


    
    
      _this.options = jQuery.extend(true, {}, jQuery.nanoGallery2.defaultOptions, options);
      // Initialization code
      _this.nG2= new nanoGALLERY2();
      _this.nG2.initiateGallery(_this.e, _this.options );
    };
      
    // PUBLIC EXPOSED METHODS
    _this.test = function() {
      //alert('test');
      // console.dir(_this.nG.G.I.length);
      // console.dir(_this.nG);
      //privateTest();
    }

    
    // Run initializer
    _this.init();
  };
 
  jQuery.nanoGallery2.defaultOptions = {
    // elements:
    //    gallery
    //      thumbnail
    //    imageDisplay - viewer?
  
    kind : '',
    userID : '',
// NEW
hiddenAlbums : '',
    photoset : '',
    blackList : 'scrapbook|profil', whiteList : '', albumList : '',
    RTL : false,
    picasaUseUrlCrossDomain : true,
    flickrSkipOriginal : true,
    //galleryToolbarWidthAligned : true, --> NG2 removed, considered as always true
    galleryToolbarHideIcons : false,
    galleryFullpageButton : false, galleryFullpageBgColor : '#111',
galleryRenderStep : 2,
// NEW
galleryLayouEngine : 'default',
    breadcrumbAutoHideTopLevel : false,
    displayBreadcrumb : false,
    theme : 'nGY2tD',
    colorScheme : 'none', colorSchemeViewer : 'default',
    items : null,
    itemsBaseURL : '',
// CHANGED from itemsSelectable to :
thumbnailSelectable : false,
// REMOVE
keepSelection: true,
// REMOVE
showCheckboxes: true,
// REMOVE
checkboxStyle : 'left:15px; top:15px;',
// REMOVE
selectMode:false,

    jsonCharset: 'Latin', jsonProvider: '',

// NEW    
galleryDisplayStep : 2,
galleryDisplayMode : 'fullContent',  // pagination, fullContent, moreButton*
    paginationMaxLinesPerPage : 1,
    // paginationDots : false, --> REMOVE in NG2
//NEW
galleryLayoutEngine : '',
    
    paginationSwipe: true,
    
// NEW
galleryPaginationMode : 'rectangles',  // 'dots', 'rectangles', 'numbers'
// NEW
galleryDisplayMoreStep : 2,
    viewer : 'internal',
    viewerFullscreen: false,
    viewerDisplayLogo : false,
    fancyBoxOptions : null,
    imageTransition : 'slide',
    openOnStart : '',
    viewerToolbar : {
      display:true, position : 'bottom', style : 'innerImage', autoMinimize:800,
      standard:'minimizeButton , previousButton, pageCounter ,nextButton,playPauseButton,fullscreenButton,infoButton,linkOriginalButton,closeButton,label',
      minimized:'minimizeButton,label'
    },
// NEW
thumbnailForNavigation : true,
    thumbnailAlignment : 'center',
    thumbnailWidth : 230, thumbnailHeight : 154,
    thumbnailGutterWidth : 2, thumbnailGutterHeight : 2,
thumbnailBorderVertical : 2, //NEW
thumbnailBorderHorizontal : 2, //NEW
// NEW:
thumbnailFeaturedKeyword : '*featured',
    thumbnailAlbumDisplayImage : false,
    thumbnailHoverEffect : null,
    thumbnailLabel : { position : 'overImageOnBottom', align: 'center', display : true, displayDescription : true, titleMaxLength : 0, descriptionMaxLength : 0, hideIcons : false, title : '', itemsCount : '', titleMultiLine: false, descriptionMultiLine: false },
// NEW
// thumbnailToolbarImage : { position: 'topRight', content : 'share,socialShare,download,openFlick,openPicasa,likeFacebook,geolocalisation' },
thumbnailToolbarImage : { topLeft: 'select', topRight : 'MEshare,featured' },
thumbnailToolbarAlbum : { topLeft: 'select', topRight : 'counter,MEshare' },
  thumbnailDisplayInterval : 20,
// CHANGED
// thumbnailDisplayTransition : 'slideUp',
thumbnailDisplayTransition : 'slideUp',
// NEW
thumbnailDisplayTransitionDuration: 400,
thumbnailDisplayTransitionInViewport: false,
thumbnailResizeTransition:true,

thumbnailRepositionTransition : true,   // NEW
// REMOVE
thumbnailLazyLoad : false, thumbnailLazyLoadTreshold : 100,

    thumbnailGlobalImageTitle : '', thumbnailGlobalAlbumTitle : '',
    //thumbnailSizeSM : 480, thumbnailSizeME : 992, thumbnailSizeLA : 1200, thumbnailSizeXL : 1800,
    breakpointSizeSM : 480, breakpointSizeME : 992, breakpointSizeLA : 1200, breakpointSizeXL : 1800,
    fnThumbnailInit : null, fnThumbnailHoverInit : null, fnThumbnailHoverResize : null, fnThumbnailHover : null, fnThumbnailHoverOut : null, fnThumbnailDisplayEffect : null,
    fnViewerInfo : null,
    fnImgToolbarCustInit : null, fnImgToolbarCustDisplay : null, fnImgToolbarCustClick : null,
    fnProcessData : null,

// called when the selection status of an item changed
fnThumbnailSelection : null,
// REMOVE
fnChangeSelectMode : null,
    fnInitGallery : null,
    touchAnimation : true, touchAutoOpenDelay : 0,
    useTags : false,
    locationHash : true,
    slideshowDelay : 3000, slideshowAutoStart : false,
    photoSorting : '', albumSorting : '', dataSorting : '',
    debugMode: false,
    

// maxWidth : 0, --> NG2 NO MORE USED
// thumbnailAdjustLastRowHeight : true, --> NO MORE USED
// lazyBuild : 'none', lazyBuildTreshold : 150, // --> REMOVED IN NG2

    i18n : {
      'breadcrumbHome' : 'Galleries', 'breadcrumbHome_FR' : 'Galeries',
      'paginationPrevious' : 'Previous', 'paginationPrevious_FR' : 'Pr&eacute;c&eacute;dent', 'paginationPrevious_DE' : 'Zur&uuml;ck', 'paginationPrevious_IT' : 'Indietro',
      'paginationNext' : 'Next', 'paginationNext_FR' : 'Suivant', 'paginationNext_DE' : 'Weiter', 'paginationNext_IT' : 'Avanti',
      'thumbnailImageTitle' : '', 'thumbnailAlbumTitle' : '',
      'thumbnailImageDescription' : '', 'thumbnailAlbumDescription' : '',
      'infoBoxPhoto' : 'Photo', 'infoBoxDate' : 'Date', 'infoBoxAlbum' : 'Album', 'infoBoxDimensions' : 'Dimensions', 'infoBoxFilename' : 'Filename', 'infoBoxFileSize' : 'File size', 'infoBoxCamera' : 'Camera', 'infoBoxFocalLength' : 'Focal length', 'infoBoxExposure' : 'Exposure', 'infoBoxFNumber' : 'F Number', 'infoBoxISO' : 'ISO', 'infoBoxMake' : 'Make', 'infoBoxFlash' : 'Flash', 'infoBoxViews' : 'Views', 'infoBoxComments' : 'Comments'
    }
  };

  jQuery.fn.nanoGallery2 = function (args, option, value) {
    if( typeof jQuery(this).data('nanoGallery2') === 'undefined'){
      return this.each( function(){
        (new jQuery.nanoGallery2(this, args));
      });
    }
    else {
      // no options -->
      // This function breaks the chain, but provides some API methods

      var nG2=$(this).data('nanoGallery2').nG2;
      switch(args){
        case 'reload':
          nG2.ReloadAlbum();
          return $(this);
          break;
        case 'itemsSelectedGet':
          return nG2.ItemsSelectedGet();
          break;
        case 'itemsSetSelectedValue':
          nG2.ItemsSetSelectedValue(option, value);
          break;
        case 'option':
          if(typeof value === 'undefined'){
            return nG2.Get(option);
          }else{
            nG2.Set(option,value);
            if( option == 'demoViewportWidth' ) {
              // force resize event -> for demo purposes
              $(window).trigger('resize');
            }
          }
          break;
        case 'destroy':
          nG2.$E.base.text('');
          $(this).removeData();
          break;
      }
      return $(this);

    }
  };
  

  // ###############################
  // ##### nanoGALLERY2 script #####
  // ###############################

  /** @function nanoGALLERY2 */
  function nanoGALLERY2() {
    "use strict";

    
        /**
    * Force reload the current album, if provided by Json
    */
    this.ReloadAlbum = function(){
      if( G.O.kind === '' ) {
        throw 'Not supported for this kind.';
      }

      var albumIdx=G.GOM.albumIdx;
      if( albumIdx == -1 ) {
        throw ('Current album not found.');
      }
      
      var albumID=G.I[albumIdx].GetID();

      // unselect everything & remove link to album (=logical delete)
      var l=G.I.length;
      for( var i=0; i < l ; i++ ) {
        var item=G.I[i];
        if( item.albumID == albumID ) {
          item.selected = false;
        }
      }
      
      G.I[albumIdx].contentIsLoaded = false;
      
      displayAlbum('-1', albumID);
    };
    
    /**
     * Set one or several items selected/unselected
     * @param {array} items
     */
    this.ItemsSetSelectedValue = function(items, value){
      var l=items.length;
      for( var j=0; j<l ; j++) {
        ThumbnailSelectionSet(items[j], value);
      }
    };
    
    /**
     * Returns an array of selected items
     * @returns {Array}
     */
    this.ItemsSelectedGet = function(){
      var selectedItems=[];
      var l=G.I.length;
      for( var i=0; i < l ; i++ ) {
        if( G.I[i].selected == true ) {
          selectedItems.push(G.I[i]);
        }
      }
      return selectedItems;
    };    
    
    /**
     * Returns the value of an option
     * @param {string} option
     * @returns {nanoGALLERY.G.O}
     */
    this.Get = function(option){
        return G.O[option];
    };

    /**
     * Set a new value for a defined option
     * @param {string} option
     */
    this.Set = function(option, value){
        G.O[option] = value;
        switch( option ) {
          case 'thumbnailSelectable':
            ThumbnailSelectionClear();
            // refresh the displayed gallery
            GalleryRender( G.GOM.albumIdx );
            break;
        }
    };
    
    
    
    
    // throttle()
    // author: underscore.js - http://underscorejs.org/docs/underscore.html
    // Returns a function, that, when invoked, will only be triggered at most once during a given window of time.
    // Normally, the throttled function will run as much as it can, without ever going more than once per wait duration;
    // but if you’d like to disable the execution on the leading edge, pass {leading: false}.
    // To disable execution on the trailing edge, ditto.
    var throttle = function(func, wait, options) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      if (!options) options = {};
      var later = function() {
        previous = options.leading === false ? 0 : new Date().getTime();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };
      return function() {
        var now = new Date().getTime();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };    

    /*
    ** Global data for this nanoGALLERY instance
    **/
    var G=this;
    G.I = [];                   // gallery items
    G.Id = [];                  // gallery items
    G.O = null;                 // user options
    G.baseEltID = null;         // ID of the base element
    G.$E = { 
      base: null,             // $g_baseControl = null,
      conTnParent: null,      // $g_containerThumbnailsParent
      conLoadingB: null,      // loading bar - nanoGalleryLBarOff
      conConsole: null,       // $g_containerConsole
      conNavB: null,          // $g_containerNavigationbar
      conNavBCon: null,       // $g_containerNavigationbarCont
      conTnBottom: null,      // container on the bottom of the gallery
      conBC: null             // $g_containerBreadcrumb
    };
    G.curNavLevel = 'l1';
    G.curWidth = 'me';
    G.layout = {                           // Layout informations
      internal : true,
      engine : '',
      support : { pagination: false },
      SetEngine: function() {
        if( G.layout.internal ) {
          if( G.tn.settings.getW() == 'auto' ) {
            G.layout.engine='JUSTIFIED';
            G.layout.support.pagination=false;
            return;
          }
          if( G.tn.settings.getH() == 'auto' ) {
            G.layout.engine='CASCADING';
            G.layout.support.pagination=false;
            return;
          }
          G.layout.support.pagination=true;
          G.layout.engine='GRID';
        }
      }
    };
    // gallery pagination
    G.pgMaxNbThumbnailsPerRow = 1;
    G.pgMaxLinesPerPage = 0;
    G.paginationCurrentPage = 0;
    G.galleryResizeEventEnabled = false;

    G.$currentTouchedThumbnail = null;    
    
    G.tn = {                          // GENERAL THUMBNAILS PROPERTIES -->
      displayInterval: 10,            // delay between 2 thumbnails display
      lazyLoadTreshold: 100,          // image lazy load treshold in pixel
      scale: 1,                       // image scale depending of the hover effect
      borderWidth: 0,                 // thumbnail container border width
      borderHeight: 0,                // thumbnail container border height
//      imgcBorderHeight: 0,            // image container border height
//      imgcBorderWidth:0 ,             // image container border width
      labelHeight: {                  // in case label on bottom, otherwise always=0
        l1:0, lN:0,
        get: function() {
          return G.tn.labelHeight[G.curNavLevel];
        }
      },
      defaultSize: {                  // default thumbnail size
                                      // annotation height is not included
        width: {  l1 : { xs:0, sm:0, me:0, la:0, xl:0 }, lN : { xs:0, sm:0, me:0, la:0, xl:0 } },
        height: { l1 : { xs:0, sm:0, me:0, la:0, xl:0 }, lN : { xs:0, sm:0, me:0, la:0, xl:0 } },
        getWidth: function() {
          return G.tn.defaultSize.width[G.curNavLevel][G.curWidth];
        },
        getOuterWidth: function() {     // width border included
          return G.tn.defaultSize.width[G.curNavLevel][G.curWidth]+G.tn.borderWidth*2;
        },
        getHeight: function() {
          return G.tn.defaultSize.height[G.curNavLevel][G.curWidth];
        },
        getOuterHeight: function() {     // height, border included
          return G.tn.defaultSize.height[G.curNavLevel][G.curWidth]+G.tn.borderHeight*2;
        }
      },
      settings: {                     // user defined width/height of the image to display depending on the screen size
        width: {  l1 : { xs:0, sm:0, me:0, la:0, xl:0, xsc:'u', smc:'u', mec:'u', lac:'u', xlc:'u' },
                  lN : { xs:0, sm:0, me:0, la:0, xl:0, xsc:'u', smc:'u', mec:'u', lac:'u', xlc:'u' } },
        height: { l1 : { xs:0, sm:0, me:0, la:0, xl:0, xsc:'u', smc:'u', mec:'u', lac:'u', xlc:'u' }, 
                  lN : { xs:0, sm:0, me:0, la:0, xl:0, xsc:'u', smc:'u', mec:'u', lac:'u', xlc:'u' } },
        getH: function() {
          return G.tn.settings.height[G.curNavLevel][G.curWidth];
        },
        getW: function() {
          return G.tn.settings.width[G.curNavLevel][G.curWidth];
        }
      },
      // thumbnail hover effects
      hoverEffects : {
        std : [],
        level1: [],
        get: function() {
          if( G.curNavLevel == 'l1' && G.tn.hoverEffects.level1.length !== 0 ) {
            return G.tn.hoverEffects.level1;
          }
          else {
            return G.tn.hoverEffects.std;
          }
        }
      },
      // thumbnail toolbars
      toolbar: {
        album : { topLeft : '', topRight: '', bottomLeft: '', bottomRight: '' },
        image : { topLeft : '', topRight: '', bottomLeft: '', bottomRight: '' },
        albumUp : { topLeft : '', topRight: '', bottomLeft: '', bottomRight: '' },
        get: function( item ) {
          return G.tn.toolbar[item.kind];
        },
      },
      style: {
        // inline CSS
        l1 : { annotation: '', label: '', title: '', desc: '' },
        lN : { annotation: '', label: '', title: '', desc: '' },
        getTitle : function() {
          return ('style="' + G.tn.style[G.curNavLevel].title + '"');
        },
        getDesc : function() {
          return ('style="' + G.tn.style[G.curNavLevel].desc + '"');
        },
        getAnnotation: function() {
          var s='style="' + G.tn.style[G.curNavLevel].annotation;
          s+= (G.O.RTL ? '"direction:RTL;"' :'');
          s+='"';
          return s;
        },
        getLabel: function() {
          // var s = 'style="margin-right:'+G.tn.toolbar.getWidth(item)+'px;';
          // var s = 'style="margin-right:'+G.tn.toolbar.getWidth(item)+'px;';
          var s='style="'+ G.tn.style[G.curNavLevel].label + '"';
          return s;
        }
      }
    };
    G.scrollTimeOut = 0;
    G.i18nTranslations = {'paginationPrevious':'Previous', 'paginationNext':'Next', 'breadcrumbHome':'List of Albums', 'thumbnailImageTitle':'', 'thumbnailAlbumTitle':'', 'thumbnailImageDescription':'', 'thumbnailAlbumDescription':'' };
    G.emptyGif = 'data:image/gif;base64,R0lGODlhEAAQAIAAAP///////yH5BAEKAAEALAAAAAAQABAAAAIOjI+py+0Po5y02ouzPgUAOw==';
    G.CSStransformName = FirstSupportedPropertyName(["transform", "msTransform", "MozTransform", "WebkitTransform", "OTransform"]);
    G.CSStransformStyle = FirstSupportedPropertyName(["transformStyle", "msTransformStyle", "MozTransformStyle", "WebkitTransformStyle", "OTransformStyle"]);
    G.CSSperspective = FirstSupportedPropertyName(["perspective", "msPerspective", "MozPerspective", "WebkitPerspective", "OPerspective"]);
    G.CSSbackfaceVisibilityName = FirstSupportedPropertyName(["backfaceVisibility", "msBackfaceVisibility", "MozBackfaceVisibility", "WebkitBackfaceVisibility", "OBackfaceVisibility"]);
    G.CSStransitionName = FirstSupportedPropertyName(["transition", "msTransition", "MozTransition", "WebkitTransition", "OTransition"]);
    G.CSSanimationName = FirstSupportedPropertyName(["animation", "msAnimation", "MozAnimation", "WebkitAnimation", "OAnimation"]);
    G.GalleryResizeThrottled = throttle(GalleryResize, 100, {leading: false});

    G.blackList = null;     // album white list
    G.whiteList = null;     // album black list
    G.albumList = null;     // album list
    G.locationHashLastUsed = '';
    G.currColorScheme = null;
    G.custGlobals = {};

    // Gallery Object Model
    G.GOM = {
      albumIdx: -1,
      displayArea : { width:0, height:0 },
      displayAreaLast : { width:0, height:0 },
      displayedSteps : 0,
      items: [],
      $imgPreloader: [],
      itemsDisplayed : 0,        // number of currently displayed thumbnails
      toolbar : { breadcrumbDisplayed : false, breadcrumbCurrentLevel : -1 },
      cache : { viewport:null, containerOffset:null },
      nbSelected : 0
    };
    function GTn(index, width, height) {
      this.thumbnailIdx = index;
      this.width = 0;
      this.height = 0;
      this.top = 0;
      this.left = 0;
      this.imageWidth = width;
      this.imageHeight = height;
      this.resizedContentWidth = 0;
      this.resizedContentHeight = 0;
      this.displayed = false;
      this.neverDisplayed = true;
    }
          
    
    // Color schemes - Gallery
    G.colorScheme_default = {
      navigationbar : { background:'none', borderTop:'1px solid #555', borderBottom:'1px solid #555', borderRight:'', borderLeft:'', color:'#ccc', colorHover:'#fff' },
      // OLD:
      //thumbnail : { background:'#000', border:'1px solid #000', labelBackground:'rgba(34, 34, 34, 0.75)', titleColor:'#eee', titleShadow:'', descriptionColor:'#ccc', descriptionShadow:'', paginationDotBorder:'2px solid #fff', paginationDotBack:'#444', paginationDotSelBack:'#fff'}    };
      // NEW:
      thumbnail : { background:'#000', borderColor:'#000', labelOpacity : 1, labelBackground:'rgba(34, 34, 34, 0.75)', titleColor:'#eee', titleShadow:'', descriptionColor:'#ccc', descriptionShadow:'', paginationShapeBorder:'2px solid #fff', paginationShapeBack:'#444', paginationShapeSelBack:'#fff'}
    };
    
    
    /** @function initiateGallery */
    this.initiateGallery = function( element, params ) {

    
      // GLOBAL OPTIONS
      G.O = params;

      // Base element
      G.$E.base = jQuery(element);
      G.baseEltID = G.$E.base.attr('id');

      defineVariables();
      
      setPolyFills();
      
      buildSkeleton();
      
      setGlobalEvents();
      

      // base album
      var itm=NGY2Item.New( G, G.i18nTranslations.breadcrumbHome, '', '0', '-1', 'album' );
      
      processStartOptions();
    }


    /** @function processStartOptions */
    function processStartOptions() {

      // hidden/private albums are loaded on plugin start
      if( G.O.hiddenAlbums != '' ) {
        jQuery.nanoGallery2.data[G.O.kind](G, 'GetHiddenAlbums', G.O.hiddenAlbums, processStartOptionsPart2);
        return;
      }
      
      processStartOptionsPart2();
      
    }

    /** @function processStartOptionsPart2 */
    function processStartOptionsPart2() {
  
      // Check location hash + start parameters -> determine what to do on start
      // openOnStart parameter
      var IDs={ albumID:'0', imageID:'0' };
      if( G.O.openOnStart != '' ) {
        IDs=parseIDs(G.O.openOnStart);
        if( IDs.imageID != '0' ) {
          displayPhoto(IDs.imageID, IDs.albumID);
          return;
        }
        else {
          displayAlbum('-1', IDs.albumID);
          return;
        }
      }
      else {
        displayAlbum('-1', 0);
      }
      
      
      //or displayAlbum(ID);
      //or displayPhoto(ID);
    }
    
    function parseIDs( IDs ) {
      var r={ albumID:'0', imageID:'0' };
      
      var t=IDs.split('/');
      if( t.length > 0 ) {
        r.albumID=t[0];
        if( t.length > 1 ) {
          r.imageID=t[1];
        }
      }
      return r;
    }
    
    function locationHashGet() {
    }

    /** @function displayAlbum */
    function displayAlbum( imageID, albumID ) {
      var idx=NGY2Item.GetIdx(G, albumID);
      if( idx == 0 ) {
        G.curNavLevel='l1'
      }
      else {
        G.curNavLevel='lN'
      }

      if( idx == -1 ) {
        NGY2Item.New( G, '', '', albumID, '0', 'album' );    // create empty album
        idx=G.I.length-1;
        idx=G.I.length-1;
      }
    
      if( !G.I[idx].contentIsLoaded ) {    // already loaded?
        albumGetContent( albumID, displayAlbum, imageID, albumID );
        return;
      }
    
      ThumbnailSelectionClear();
    
//      alert('album ok -> ready to render');
      G.paginationCurrentPage=0;
      GalleryRender( idx );
      // render gallery
      // set G.locationHashLastUsed if different then G.locationHashLastUsed
    
    }


    // manage the bottom area of the gallery -> "pagination" or "more button"
    function GalleryBottomManage( ) {
    
//G.galleryBottomCurrent : 'PAGINATION', 'MOREBUTTON', ''
      switch( G.O.galleryDisplayMode ) {
        case 'PAGINATION':
          if( G.layout.support.pagination && G.pgMaxLinesPerPage > 0 ) {
            managePagination( G.GOM.albumIdx );
          }
          break;
        case 'MOREBUTTON':
          G.$E.conTnBottom.off('click');
          var nb=G.GOM.items.length-G.GOM.itemsDisplayed;
          if( nb == 0 ) {
            G.$E.conTnBottom.empty();
          }
          else {
            G.$E.conTnBottom.html('<div class="nGY2GalleryMoreButton"><div class="nGY2GalleryMoreButtonAnnotation">+'+nb+'</div></div>');
            G.$E.conTnBottom.on('click', function(e) {
              G.GOM.displayedSteps++;
              GalleryResize();
            });
          }
          break;
        case 'FULLCONTENT':
        default:
          break;
      }
    
    }
    
    
        // add album to breadcrumb
    function breadcrumbAdd( albumIdx ) {
      
      var cl="folder";
      if(albumIdx == 0 ) {
        cl="folderHome";
      }
      var $newDiv =jQuery('<div class="'+cl+' oneFolder">'+G.I[albumIdx].title+'</div>').appendTo(G.$E.conBC);
      jQuery($newDiv).data('albumIdx',albumIdx);
      $newDiv.click(function() {
        var cAlbumIdx=jQuery(this).data('albumIdx');
        jQuery(this).nextAll().remove();
        // OpenAlbum(cAlbumIdx, false, -1, true);
        displayAlbum('-1', G.I[cAlbumIdx].GetID());
        return;
      });
    }

    // add separator to breadcrumb
    function breadcrumbAddSeparator( lastAlbumID ) {
      var $newSep=jQuery('<div class="separator'+(G.O.RTL ? 'RTL' : '')+'"></div>').appendTo(G.$E.conBC);
      jQuery($newSep).data('albumIdx',lastAlbumID);
      $newSep.click(function() {
        var sepAlbumIdx=jQuery(this).data('albumIdx');
        jQuery(this).nextAll().remove();
        jQuery(this).remove();
        //OpenAlbum(sepAlbumIdx, false, -1, true);
        displayAlbum('-1', G.I[sepAlbumIdx].GetID());
        return;
      });
    }

    
    
    // Manage the gallery toolbar (at this time only the breadcrumb)
    function GalleryToolbar( albumIdx ) {

      // manage breadcrumb
      if( G.O.displayBreadcrumb == true && !G.O.thumbnailAlbumDisplayImage ) {
      
        // retrieve new folder level
        var newLevel = 0,
        lstItems=[];
        if( albumIdx != 0 ) {
          var l=G.I.length,
          parentID=0;
          
          lstItems.push(albumIdx);
          var curIdx=albumIdx;
          newLevel++;
          
          while( G.I[curIdx].albumID != 0 && G.I[curIdx].albumID != -1) {
            for(var i=1; i < l; i++ ) {
              if( G.I[i].GetID() == G.I[curIdx].albumID ) {
                curIdx=i;
                lstItems.push(curIdx);
                newLevel++;
                break;
              }
            }
          }
        }
        
        
        if( newLevel == G.GOM.toolbar.breadcrumbCurrentLevel ) {
          // do nothing
        }
        else {
          // rebuild breadcrumd
          if( G.O.breadcrumbAutoHideTopLevel ) {
            if( newLevel == 0 && ( G.GOM.toolbar.breadcrumbCurrentLevel > 0 || G.GOM.toolbar.breadcrumbCurrentLevel == -1 ) ) {
              // hide toolbar
              G.GOM.toolbar.breadcrumbCurrentLevel=newLevel;
              return 'animateHide';
            }
            if( newLevel > 0 && ( G.GOM.toolbar.breadcrumbCurrentLevel == 0 || G.GOM.toolbar.breadcrumbCurrentLevel == -1) ) {
              // display toolbar
              BreacrumbBuild(lstItems);
              G.GOM.toolbar.breadcrumbCurrentLevel=newLevel;
              return 'animateDisplay';
            }
          }
          else {
            BreacrumbBuild(lstItems);            
          }
        }
        G.GOM.toolbar.breadcrumbCurrentLevel=newLevel;
      }
      else {
        // no toolbar
        G.$E.conNavBCon.css({opacity:0, 'height':0});
      }
      

    }
    
    function BreacrumbBuild(lstItems) {

      G.$E.conBC.children().remove();
      
      breadcrumbAdd(0);
      if( lstItems.length > 0 ) {
        breadcrumbAddSeparator(0);
        for(var i=lstItems.length-1; i>=0 ; i-- ) {
          breadcrumbAdd(lstItems[i]);
          if( i > 0 ) {
            breadcrumbAddSeparator(lstItems[i-1]);
          }
        }
      }
    
    }
    
    
    // Display pagination
    function managePagination( albumIdx ) {
      
      G.$E.conTnBottom.children().remove();

      var interval = GalleryRenderGetInterval();
      
      if( interval.len == 0 || G.O.galleryDisplayMode.toUpperCase() != 'PAGINATION' ) {
        // no pagination --> exit
        return;
      }
      
      //G.$E.conTnBottom.data('galleryIdx',albumIdx);
      var n2=0;
      // display "previous"
      if( G.O.galleryPaginationMode == 'NUMBERS' && G.paginationCurrentPage > 0 ) {
        var $eltPrev=jQuery('<div class="nGY2PaginationPrev">'+ G.i18nTranslations.paginationPrevious +'</div>').appendTo(G.$E.conTnBottom);
        $eltPrev.click(function(e) {
          paginationPreviousPage();
        });
      }

      var firstPage=0;
      // pagination - max lines per page mode
      n2=Math.ceil(G.I[albumIdx].contentLength/(G.pgMaxLinesPerPage*G.pgMaxNbThumbnailsPerRow));

      // no previous/next
      if( G.O.galleryPaginationMode != 'NUMBERS' ) {
        firstPage=0;
      }
      else {
        if( G.paginationCurrentPage >= 5 ) {
          firstPage=G.paginationCurrentPage-5;
          if( n2 > G.paginationCurrentPage+6 ) {
            n2=G.paginationCurrentPage+6;
          }
        }
        else {
          if( n2 > 10 ) {
            n2=10;
          }
        }
      }

      // only one page -> do not display anything
      if( n2==1 ) {
        return;
      }

      for(var i=firstPage; i < n2; i++ ) {
      var c='';
        var p='';

        switch( G.O.galleryPaginationMode ) {
          case 'NUMBERS':
            c='nGY2paginationItem';
            p=i+1;
            break;
          case 'DOTS':
            c='nGY2paginationDot';
            break;
          case 'RECTANGLES':
            c='nGY2paginationRectangle';
            break;
        }
        if( i == G.paginationCurrentPage ) {
          c+='CurrentPage';
        }

        var elt$=jQuery('<div class="'+c+'">'+p+'</div>').appendTo(G.$E.conTnBottom);
        elt$.data('pageNumber',i);
        elt$.click(function(e) {
          //var aIdx=G.$E.conTnBottom.data('galleryIdx');
          G.paginationCurrentPage=jQuery(this).data('pageNumber');
          GalleryRender(G.GOM.albumIdx);
        });

      }

      // display "next"
      if( G.O.galleryPaginationMode == 'NUMBERS' && (G.paginationCurrentPage+1) < n2 ) {
        var $eltNext=jQuery('<div class="nGY2PaginationNext">'+ G.i18nTranslations.paginationNext +'</div>').appendTo(G.$E.conTnBottom);
        $eltNext.click(function(e) {
          paginationNextPage();
        });
      }

    }

    function paginationNextPage() {
      // var aIdx=G.$E.conTnBottom.data('galleryIdx'),
      var aIdx=G.GOM.albumIdx,
      n1=0;
      
      // pagination - max lines per page mode
      if( G.pgMaxLinesPerPage > 0 ) {
        n1=G.I[aIdx].contentLength / (G.pgMaxLinesPerPage * G.pgMaxNbThumbnailsPerRow);
      }
      var n2=Math.ceil(n1);
      
      // var pn=G.$E.conTnBottom.data('currentPageNumber');
      var pn=G.paginationCurrentPage;
      if( pn < (n2-1) ) {
        pn++;
      }
      else {
        pn=0;
      }
      
      G.paginationCurrentPage = pn;
      GalleryRender(aIdx);
    }
    
    function paginationPreviousPage() {
      // var aIdx=G.$E.conTnBottom.data('galleryIdx'),
      var aIdx=G.GOM.albumIdx,
      n1=0;
      
      // pagination - max lines per page mode
      if( G.pgMaxLinesPerPage > 0 ) {
        n1=G.I[aIdx].contentLength / (G.pgMaxLinesPerPage * G.pgMaxNbThumbnailsPerRow);
      }
      var n2=Math.ceil(n1);
      
      // var pn=G.$E.conTnBottom.data('currentPageNumber');
      var pn=G.paginationCurrentPage;
      if( pn > 0 ) {
        pn--;
      }
      else {
        pn=n2-1;
      }

      G.paginationCurrentPage = pn;
      GalleryRender(aIdx);
    }


    function GalleryRenderGetInterval() {
      var albumIdx=G.GOM.albumIdx;
      var interval={ from:0, len: G.I.length };

      switch( G.O.galleryDisplayMode ) {
        case 'PAGINATION':
          G.I[albumIdx].paginationLastPage=G.paginationCurrentPage;
          if( G.layout.support.pagination && G.pgMaxLinesPerPage > 0) {
            interval.len= G.pgMaxLinesPerPage * G.pgMaxNbThumbnailsPerRow;
            interval.from= G.paginationCurrentPage * interval.len;
            // interval.len=interval.from+G.pgMaxLinesPerPage*G.pgMaxNbThumbnailsPerRow;
          }
          break;
        case 'MOREBUTTON':
          break;
        case 'FULLCONTENT':
        default:
          break;
      }
      
      return interval;
    }
    
    
    // RENDER THE GALLERY
    function GalleryRender( albumIdx ) {
      G.galleryResizeEventEnabled=false;
      G.GOM.albumIdx = -1;

      // pagination
      if( G.$E.conTnBottom !== undefined ) {
        // G.$E.conTnBottom.children().remove();
        G.$E.conTnBottom.empty();
      }

      // scroll to top of the gallery if needed
      var wp=getViewport();
      var galleryOTop=G.$E.base.offset().top;
      if( galleryOTop < wp.t ) {
        jQuery('html, body').animate({scrollTop: galleryOTop}, 200);
      }

      // breadcrumb
      switch( GalleryToolbar(albumIdx) ) {
        case 'animateDisplay':
          var toH=G.$E.conNavBCon.get(0).scrollHeight;
          var tweenable = new NGTweenable();
          tweenable.tween({
            // from: {'opacity':0,'max-height':0},
            from: {'opacity':0,'height':0},
            to: {'opacity':'1','height':toH},
            attachment: { h:toH },
            duration: 200,
            easing: 'easeInQuart',
            step: function (state, att) {
              G.$E.conTnParent.css('opacity',1-state.opacity);
              // G.$E.conNavBCon.css(state);
              G.$E.conNavBCon.css({'opacity':state.opacity});
            },
            finish: function (state, att) {
              G.$E.conTnParent.css({'opacity': 0});
              // G.$E.conNavBCon.css({'opacity':1 ,'height':att.h});
              // G.$E.conNavBCon.css({'opacity':1});
              G.$E.conNavBCon.css({'opacity':1, display:'block'});
              GalleryRenderPart2(albumIdx);
            }
          });
          break;
        case 'animateHide':
          var tweenable = new NGTweenable();
          tweenable.tween({
            from: {'opacity':1,'height':G.$E.conNavBCon.height()},
            to: {'opacity':'0','height':0},
            duration: 200,
            easing: 'easeInQuart',
            step: function (state) {
              G.$E.conTnParent.css('opacity', state.opacity);
              // G.$E.conNavBCon.css(state);
              G.$E.conNavBCon.css({'opacity':state.opacity});
            },
            finish: function (state) {
              G.$E.conTnParent.css({'opacity': 0});
              G.$E.conNavBCon.css({'opacity':0, display:'none'});
              // G.$E.conNavBCon.css({'opacity':0,'height':0});
              
              GalleryRenderPart2(albumIdx);
            }
          });
          break;
        default:
          var tweenable = new NGTweenable();
          tweenable.tween({
            from:       {'opacity': 1 },
            to:         {'opacity': 0 },
            duration: 150,
            easing: 'easeInQuart',
            step: function (state) {
              G.$E.conTnParent.css(state);
            },
            finish: function (state) {
              G.$E.conTnParent.css({'opacity': 0 });
              if( G.O.displayBreadcrumb == true ) {
                G.$E.conNavBCon.css({'opacity':1, display:'block'});
              }
              GalleryRenderPart2(albumIdx);
            }
          });
          break;
      }
    }
    
    // Gallery render part 2 -> remove all thumbnails
    function GalleryRenderPart2(albumIdx) {
      G.$E.conTnParent.css({'opacity': 0 });
      // G.$E.conTn.hide(0).off().show(0).html('');
      // G.$E.conTn.off().html('');
      G.$E.conTn.off().empty();
      var l=G.I.length;
      for( var i=0; i < l ; i++ ) {
        // reset each item
        var item=G.I[i];
        item.hovered=false;
        item.$elt=null;
        item.$Elts=[];
        item.eltTransform=null;
        item.width=0;
        item.height=0;
        item.left=0;
        item.top=0;
        item.resizedContentWidth=0;
        item.resizedContentHeight=0;
      }

      ElementTranslateX(G.$E.conTn[0],0);
      G.$E.conTnParent.css({ left:0, opacity:1 });

      G.pgMaxNbThumbnailsPerRow=NbThumbnailsPerRow();
      GalleryRenderPart3(albumIdx);

    }
    
    // Gallery render part 2 -> start building the new gallery
    function GalleryRenderPart3(albumIdx) {
      var d=new Date();      

      G.GOM.items = [];
      G.GOM.displayedSteps=0;
// retrieve annotation height      
      var annotationHeight = 0;
      if( G.O.thumbnailLabel.get('position') == 'onBottom' ) {
        annotationHeight=ThumbnailGetAnnotationHeight();
        G.tn.labelHeight[G.curNavLevel]=annotationHeight;
      }
      else {
        G.tn.labelHeight[G.curNavLevel]=0;
      }
      G.GOM.albumIdx=albumIdx;
      var interval = GalleryRenderGetInterval();
      
      var imageSizeRequired=false;
      if( G.layout.engine == 'JUSTIFIED' || G.layout.engine == 'CASCADING' ) {
        imageSizeRequired=true;
      }
      var imageSizeRequested=false;
      var preloadImages;

      
      // step 1: retrieve and store all the thumbnails of the current album
      var cnt=0;
      var idx=0;
      var l=G.I.length;
      var from=0;
      do {
        var item=G.I[idx];
        // check album
        if( item.albumID == G.I[albumIdx].GetID() ) {
          if( from >= interval.from ) {
            // use thumbnail image size
            var w=item.thumbImg(G).width;
            var h=item.thumbImg(G).height;
            // if unknow image size and layout is not grid --> we need to retrieve the size of the images
            if( imageSizeRequired && ( w == 0 || h == 0) ) {
              imageSizeRequested=true;
              preloadImages+='<img src="'+item.thumbImg(G).src+'" data-idx="'+cnt+'" data-albumidx="'+G.GOM.albumIdx+'">';
            }
            
            // set default size if required
            if( h == 0 ) {
              h=G.tn.defaultSize.getHeight();
            }
            if( w == 0 ) {
              w=G.tn.defaultSize.getWidth();
            }
            
            // add border and annotation height to have the size of the thumbanil
            // w+=G.tn.borderWidth*2;
            // h+=G.tn.borderHeight*2 + annotationHeight;
            var tn=new GTn(idx, w, h);
            G.GOM.items.push(tn);
            cnt++;
          }
          from++;
        }
        idx++;
      } while( cnt < interval.len && idx < l )

      if( !(imageSizeRequired && imageSizeRequested) ) {

        // G.galleryResizeEventEnabled=true;
        // debounce( OnScrollEvent, 150, false);
        // step 2: apply layout
        GallerySetLayout();
        
        // step 3: display gallery
        GalleryDisplay();
      }
      else {
        // preload images to retrieve their size and then resize the gallery (=GallerySetLayout()+ GalleryDisplay())
          var $newImg=jQuery(preloadImages);
          var gi_imgLoad = ngimagesLoaded( $newImg );
          $newImg=null;
          gi_imgLoad.on( 'progress', function( instance, image ) {
          
            if( image.isLoaded ) {
              var idx=image.img.getAttribute('data-idx');
              var albumIdx=image.img.getAttribute('data-albumidx');
              if( albumIdx == G.GOM.albumIdx ) {
                // ignore event if not on current album
                var curTn=G.GOM.items[idx];
                curTn.imageWidth=image.img.naturalWidth;
                curTn.imageHeight=image.img.naturalHeight;
                var item=G.I[curTn.thumbnailIdx];
                item.thumbs.width[G.curNavLevel][G.curWidth]=curTn.imageWidth;
                item.thumbs.height[G.curNavLevel][G.curWidth]=curTn.imageHeight;

                G.GalleryResizeThrottled();
                
                // set the retrieved size to all levels with same configuration  
                var object=item.thumbs.width.l1;
                for (var property in object) {
                  if (object.hasOwnProperty(property)) {
                    if( property != G.curWidth ) {
                      if( G.tn.settings.width.l1[property] == G.tn.settings.width[G.curNavLevel][G.curWidth] && G.tn.settings.height.l1[property] == G.tn.settings.height[G.curNavLevel][G.curWidth] ) {
                        item.thumbs.width.l1[property]=curTn.imageWidth;
                        item.thumbs.height.l1[property]=curTn.imageHeight;
                      }
                    }
                  }
                }
                object=item.thumbs.width.lN;
                for (var property in object) {
                  if (object.hasOwnProperty(property)) {
                    if( property != G.curWidth ) {
                      if( G.tn.settings.width.lN[property] == G.tn.settings.width[G.curNavLevel][G.curWidth] && G.tn.settings.height.lN[property] == G.tn.settings.height[G.curNavLevel][G.curWidth] ) {
                        item.thumbs.width.lN[property]=curTn.imageWidth;
                        item.thumbs.height.lN[property]=curTn.imageHeight;
                      }
                    }
                  }
                }
              }
            }
          });
          G.galleryResizeEventEnabled=true;
        }

//      G.containerThumbnailsDisplayed=true;
      
      G.GOM.albumIdx = albumIdx;
//      G.curAlbumIdx=albumIdx; --> DO NOT USE ANYMORE!!!
      // G.galleryResizeEventEnabled=true;
      if( G.O.debugMode ) {
        console.log('GalleryRenderPart3: '+ (new Date()-d));
      }

    }
    
    function GalleryResize() {
      var d=new Date();
      G.galleryResizeEventEnabled=false;
      if( GallerySetLayout() == false ) {
        G.galleryResizeEventEnabled=true;
        if( G.O.debugMode ) {
          console.log('GalleryResize1: '+ (new Date()-d));
        }
        return;
      }
      if( G.O.debugMode ) {
        console.log('GalleryResizeSetLayout: '+ (new Date()-d));
      }

      GalleryDisplay();

      // G.galleryResizeEventEnabled=true;
      if( G.O.debugMode ) {
        console.log('GalleryResizeFull: '+ (new Date()-d));
      }
    }
    
    function GallerySetLayout() {
      // available area width
      var areaWidth=G.$E.conTnParent.width();
      G.GOM.displayArea={ width:0, height:0 };

      switch( G.layout.engine ) {
        case 'JUSTIFIED':
          return GallerySetLayoutWidthtAuto( areaWidth );
        case 'GRID':
        default:
          return GallerySetLayoutGrid( areaWidth );
      }

    }
    
    function GallerySetLayoutWidthtAuto( areaWidth ) {

      var curWidth=0,
      lastPosX=0,
      curPosY=0,
      rowLastItem=[],
      rowNum=0,
      rowHeight=[],
      bNewRow=false,
      cnt=0,
      gutterWidth=G.O.thumbnailGutterWidth,
      gutterHeight=G.O.thumbnailGutterHeight;
      // by grief-of-these-days
      var maxRowHeightVertical=0;     // max height of a row with vertical thumbs
      var maxRowHeightHorizontal=0;   // max height of a row with horizontal thumbs
      var rowHasVertical=false;       // current row has vertical thumbs
      var rowHasHorizontal=false;     // current row has horizontal thumbs

      var tnHeight=G.tn.defaultSize.getOuterHeight();
      var borderWidth=G.tn.borderWidth*2;
      var borderHeight=G.tn.borderHeight*2;
      var nbTnInCurrRow=1;
      var nbTn=G.GOM.items.length;

      // first loop --> retrieve each row image height
      for( var i=0; i < nbTn ; i++ ) {
        var curTn=G.GOM.items[i];
        if( curTn.imageWidth > 0 ) {
          var imageRatio=curTn.imageWidth/curTn.imageHeight;
          var imageWidth=Math.floor(tnHeight*imageRatio);

          if( bNewRow ) {
            bNewRow=false;
            rowNum++;
            curWidth=0;
            rowHasVertical=false;
            rowHasHorizontal=false;
            nbTnInCurrRow=1;
          }
          // by grief-of-these-days
          if( curTn.imageHeight > curTn.imageWidth ) {
            rowHasVertical = true;
          }
          else {
            rowHasHorizontal = true;
          }
          
          if( (curWidth + gutterWidth + imageWidth) < (areaWidth - (nbTnInCurrRow*borderWidth)) ) {
            // enough place left in the current row
            curWidth+=imageWidth+gutterWidth;
            rowHeight[rowNum]=tnHeight;
            
            // prevent incomplete row from being heigher than the previous ones.
            // by grief-of-these-days
            var rowHeightLimit=Math.max(rowHasVertical ? maxRowHeightVertical : 0, rowHasHorizontal ? maxRowHeightHorizontal : 0);
            if( rowHeightLimit > 0 ) {
              rowHeight[rowNum]=Math.min(rowHeight[rowNum],rowHeightLimit);
            }
            
            rowLastItem[rowNum]=i;
          }
          else {
            // new row after current item --> we need to adujet the row height to have enough space for the current thumbnail
            curWidth+=gutterWidth+imageWidth;
            var ratio=(areaWidth-nbTnInCurrRow*borderWidth) / curWidth;
            var rH=Math.floor(tnHeight*ratio);
            rowHeight[rowNum]=rH;
            
            // save the max row height for each thumb orientation.
            // by grief-of-these-days
            if( rowHasVertical ) {
              maxRowHeightVertical=Math.max(maxRowHeightVertical,rH);
            }
            if( rowHasHorizontal ) {
              maxRowHeightHorizontal=Math.max(maxRowHeightHorizontal,rH);
            }
            
            rowLastItem[rowNum]=i;
            bNewRow=true;
          }
          cnt++;
          nbTnInCurrRow++;
        }


      }

      rowNum=0;
      curPosY=0;
      lastPosX=0;
      cnt=0;
      
      // second loop --> calculate each thumbnail size
      for( var i=0; i < nbTn ; i++ ) {
        var curTn=G.GOM.items[i];
        if( curTn.imageWidth > 0 ) {
          var imageRatio=curTn.imageWidth/curTn.imageHeight;
          var imageWidth=Math.floor(imageRatio*rowHeight[rowNum]); // border is already NOT included

          if( i == rowLastItem[rowNum] ) {
            // row last item --> adjust image width because of rounding problems
            if( rowLastItem.length != (rowNum+1) ) {
              // last item in current row -> use the full remaining width
              imageWidth=areaWidth-lastPosX-borderWidth;
            }
            else {
              // very last item (on the last row)
              if( (lastPosX + gutterWidth + imageWidth + borderWidth ) > areaWidth ) {
                // reduce size if image is wider as the remaining space
                imageWidth=areaWidth-lastPosX-borderWidth;
              }
            }
          }
          
          var rh=parseInt(rowHeight[rowNum]);
          imageWidth=parseInt(imageWidth);

          // thumbnail image size
          curTn.resizedContentWidth=imageWidth;
          curTn.resizedContentHeight=rh;
          // thumbnail position and size
          curTn.width=imageWidth+borderWidth;
          curTn.height=rh+G.tn.labelHeight.get()+borderHeight;

          curTn.top=curPosY;
          var x=lastPosX;
          if( G.O.RTL) {
            x=areaWidth - lastPosX - curTn.width ;
          }
          curTn.left=x;

          lastPosX+=curTn.width+gutterWidth;

          if( i == rowLastItem[rowNum] ) {
            // start a new row
            curPosY+=curTn.height+gutterHeight;
            rowNum++;
            lastPosX=0;
          }
          cnt++;
        }
        else {
          return false;
        }
      }
      
      // size of the really used area
      G.GOM.displayArea={ width:areaWidth, height: curPosY };

      return true;
    }    
    
    function GallerySetLayoutGrid( areaWidth ) {
      var curPosX=0,
      curPosY=0,   
      gutterWidth=0,
      gutterHeight=G.O.thumbnailGutterHeight,
      maxCol=NbThumbnailsPerRow(),
      w=0,
      cols=[],
      curCol=0,
      newAreaWidth = areaWidth,
      tnWidth=G.tn.defaultSize.getOuterWidth(),
      tnHeight=G.tn.defaultSize.getOuterHeight()+G.tn.labelHeight.get();

      // pagination - max lines per page mode
      if( G.O.galleryDisplayMode == 'PAGINATION' && G.pgMaxLinesPerPage > 0 && tnWidth > 0 ) {
        if( maxCol != G.pgMaxNbThumbnailsPerRow ) {   // max number of thumbnails per line has changed --> render the gallery again
          G.pgMaxNbThumbnailsPerRow=maxCol;
          GalleryRender( G.GOM.albumIdx );
          return false;
        }
      }      
      
      var nbTn=G.GOM.items.length;
      
      // retrieve gutter width
      if( G.O.thumbnailAlignment == 'justified' ) {
        maxCol=Math.min(maxCol,nbTn);
        gutterWidth=(maxCol==1?0:(areaWidth-(maxCol*tnWidth))/(maxCol-1));
      }
      else {
        gutterWidth=G.O.thumbnailGutterWidth;
      }

      if( G.O.RTL ) {
        // first loop to retrieve the real used width of the area
        for( var i=0; i < nbTn ; i++ ) {
          if( curPosY != 0 ) {
            break;
          }
          else {
            curPosX=curCol*(tnWidth+gutterWidth);
            cols[curCol]=curPosX;
            w=curPosX;
          }
          
          curCol++;
          if( curCol >= maxCol ){
            curCol=0;
            curPosY+=tnHeight+gutterHeight;
          }
        }
        newAreaWidth=w+tnWidth;
        curPosY=0;
        curCol=0;
      }
      
      var lastPosY=0;
      for( var i=0; i < nbTn ; i++ ) {
        if( curPosY == 0 ) {
          curPosX=curCol*(tnWidth+gutterWidth)
          cols[curCol]=curPosX;
          w=curPosX + tnWidth;
        }
        else {
          curPosX=cols[curCol];
        }

        var x=curPosX;
        if( G.O.RTL ) {
          x=parseInt(newAreaWidth)-curPosX-tnWidth;
        }
        
        // MANDATORY : set thumbnail position AND size
        var curTn=G.GOM.items[i];
        curTn.top=curPosY;
        curTn.left=x;
        curTn.height=tnHeight;
        curTn.width=tnWidth;
        lastPosY=curPosY;

        curCol++;
        if( curCol >= maxCol ){
          curCol=0;
          curPosY+=tnHeight+gutterHeight;
        }
      }
      
      // size of the really used area
      G.GOM.displayArea={ width:w, height:lastPosY+tnHeight };

      return true;
    }

    function GalleryDisplay() {
      var nbTn=G.GOM.items.length;
      var nbLines=0;
      var lastPosY=0;
      var removeTn=false;
      
      G.GOM.itemsDisplayed=0;
      var threshold = 50;
      var cnt=0;    // counter for delay between each thumbnail display
      
      var vp=getViewport();
      G.GOM.cache.viewport=vp;

      var containerOffset=G.$E.conTnParent.offset();
      G.GOM.cache.containerOffset=containerOffset;

      
      var tnToDisplay = [];
      var tnToReDisplay = [];
      
      // NOTE: loop always the whole GOM.items --> in case an already displayed thumbnail needs to be removed
      for( var i=0; i < nbTn ; i++ ) {
        var curTn=G.GOM.items[i];
        // "more" button
        if( G.O.galleryDisplayMode == 'MOREBUTTON' && removeTn == false ) {
          if( curTn.top > lastPosY ) {
            nbLines++;
            lastPosY=curTn.top;
            if( nbLines >= (G.O.galleryDisplayStep* (G.GOM.displayedSteps+1) ) ) {
              G.GOM.displayArea.height=lastPosY;
              removeTn=true;
            }
          }
        }
        
        if( removeTn == false ) {
          // if( !curTn.displayed ) {
          if( curTn.neverDisplayed ) {
            // thumbnail is not displayed -> check if in viewport to display or not
            var top=containerOffset.top+curTn.top;
            // var left=containerOffset.left+curTn.left;
            if( (top+curTn.height) >= (vp.t-threshold) && top <= (vp.t+vp.h+threshold) ) {
                // build thumbnail
                var item=G.I[curTn.thumbnailIdx];
                if( item.$elt == null ) {
                  thumbnailBuild( item, curTn.thumbnailIdx, i );
                }
                tnToDisplay.push({idx:i, delay:cnt});
                cnt++;
              }
          }
          else {
            tnToReDisplay.push({idx:i, delay:0});
          }
          G.GOM.itemsDisplayed++;
        }
        else {
          curTn.displayed=false;
          var item=G.I[curTn.thumbnailIdx];
          // var item=G.I[curTn.thumbnailIdx];
          if( item.$elt != null ){
            item.$elt.css({ opacity: 0 });
          }
        }
        
      }

      // set gallery area really used size
      if( G.GOM.displayArea.width != G.GOM.displayAreaLast.width || G.GOM.displayArea.height != G.GOM.displayAreaLast.height ) {
        G.$E.conTn.width(G.GOM.displayArea.width).height(G.GOM.displayArea.height);
        G.GOM.displayAreaLast.width=G.GOM.displayArea.width;
        G.GOM.displayAreaLast.height=G.GOM.displayArea.height;
      }

      // bottom of the gallery (pagination, more button...)
      GalleryBottomManage();

      
      // batch set position (and display animation) to all thumbnails
      // first display newly built thumbnails
      var nbBuild=tnToDisplay.length;
      for( var i=0; i < nbBuild ; i++ ) {
        ThumbnailSetPosition(tnToDisplay[i].idx,tnToDisplay[i].delay+10);
      }
      // then re-position already displayed thumbnails
      var n=tnToReDisplay.length;
      for( var i=0; i < n ; i++ ) {
        ThumbnailSetPosition(tnToReDisplay[i].idx,nbBuild+1);
      }

      if( G.O.thumbnailDisplayTransition === false || G.O.thumbnailDisplayTransition == 'NONE' ) {
        G.galleryResizeEventEnabled=true;
      }
      else {
        setTimeout(function() {
          // change value after the end of the display transistion of the newly built thumbnails
          G.galleryResizeEventEnabled=true;
        }, nbBuild*G.tn.displayInterval);
      }
      
    }
    
    
    // Thumbnail: set the new position
    function ThumbnailSetPosition( GOMidx, cnt ) {

      var curTn=G.GOM.items[GOMidx];
      var idx=G.GOM.items[GOMidx].thumbnailIdx;
      var item=G.I[idx];
    
      if( curTn.neverDisplayed ) {
        // thumbnail is built but has never been displayed (=first display)
        item.$elt.css({ display: 'block', top: curTn.top , left: curTn.left });
        ThumbnailAppear(GOMidx, cnt);
        curTn.displayed=true;
        curTn.neverDisplayed=false;
      }
      else {
        var topOld=G.GOM.cache.containerOffset.top+item.top;
        var top=G.GOM.cache.containerOffset.top+curTn.top;
        var vp=G.GOM.cache.viewport;
        if( ( (topOld+curTn.height) >= (vp.t-vp.h) && topOld <= (vp.t+vp.h*2) ) ||
              ( (top+curTn.height) >= (vp.t-vp.h) && top <= (vp.t+vp.h*2) )  ) {
          // thumbnail positioned in enlarged viewport (viewport + 2 x viewport height)
          if( curTn.displayed ) {
            // thumbnail is displayed
            if( item.top != curTn.top || item.left != curTn.left ) {
              // set position
              if( G.O.thumbnailResizeTransition == true ) {
                // with transition
                var tweenable = new NGTweenable();
                tweenable.tween({
                  from:     { 'top': item.top, 'left': item.left },
                  to:       { 'top': curTn.top, 'left': curTn.left },
                  attachment: { $e: item.$elt },
                  duration: 300,
                  delay: cnt*G.tn.displayInterval,
                  easing: 'easeOutQuart',
                  step: function (state, att) {
                    att.$e.css(state);
                  },
                  finish: function (state, att) {
                    att.$e.css(state);
                    this.dispose();
                  }
                });
              }
              else {
                // set position without transition
                item.$elt.css({ top: curTn.top , left: curTn.left });
              }
            }
          }
          else {
            // re-display thumbnail
            curTn.displayed=true;
            item.$elt.css({ display: 'block', top: curTn.top , left: curTn.left });
          }
        }
        else {
          // undisplay thumbnail --> performance gain
          curTn.displayed=false;
          item.$elt.css({ display: 'none'});
        }
      }
      item.left=curTn.left;
      item.top=curTn.top;
      
      if( item.width != curTn.width || item.height != curTn.height ) {
        item.$elt.css({ width: curTn.width , height: curTn.height });
        item.width=curTn.width;
        item.height=curTn.height;
        
        // if( curTn.resizedContentWidth > 0 ) {
        // resize also the content (=image)
        if( item.resizedContentWidth != curTn.resizedContentWidth && item.resizedContentHeight != curTn.resizedContentHeight ) {
          if( item.kind == 'albumUp' ) {
            // item.$getElt('.nGY2GThumbnailAlbumUp').css({'height': curTn.resizedContentHeight, 'width': curTn.resizedContentWidth});
          }
          else {
            item.$getElt('.nGY2GThumbnailImg').css({'height': curTn.resizedContentHeight, 'width': curTn.resizedContentWidth});
            item.$getElt('.nGY2GThumbnailImage').css({'height': curTn.resizedContentHeight, 'width': curTn.resizedContentWidth});
          }
          item.resizedContentWidth=curTn.resizedContentWidth;
          item.resizedContentHeight=curTn.resizedContentHeight;


        }
        // only if thumbnail is resized
        ThumbnailOverResize(GOMidx);
        
      }

    }
    
    
    // Compute the height of the annotation part of a thumbnail (title+description, both single line)
    function ThumbnailGetAnnotationHeight() {
      var newElt=[],
      newEltIdx=0;

      // if( G.O.thumbnailLabel.get('display') == false && G.tn.toolbar.getWidth(item) <= 0 ) {
      if( G.O.thumbnailLabel.get('display') == false  ) {
        return 0;
      }
      
      var desc='';
      if( G.O.thumbnailLabel.get('displayDescription') == true ) {
        desc='aAzZjJ';
      }

      // visibility set to hidden
      newElt[newEltIdx++]='<div class="nGY2GThumbnail '+G.O.theme+'" style="display:block;visibility:hidden;position:absolute;top:-9999px;left:-9999px;" ><div class="nGY2GThumbnailSub">';
      if( G.O.thumbnailLabel.get('display') == true ) {
        // Labels: title and description
        newElt[newEltIdx++]= '  <div class="nGY2GThumbnailLabel" '+ G.tn.style.getLabel() +'>';
        newElt[newEltIdx++]= '    <div class="nGY2GThumbnailAlbumTitle" '+G.tn.style.getTitle()+'>aAzZjJ</div>';
        newElt[newEltIdx++]= '    <div class="nGY2GThumbnailDescription" '+G.tn.style.getDesc()+'>'+desc+'</div>';
        newElt[newEltIdx++]= '  </div>';
      }
      
      newElt[newEltIdx++]='</div></div>';
    
      var $newDiv =jQuery(newElt.join('')).appendTo('body');
      var h=$newDiv.find('.nGY2GThumbnailLabel').outerHeight(true);
      $newDiv.remove();
      
      return h;
    }
    
    function ThumbnailBuildAlbumpUp( item, idx, GOMidx ) {
      var newElt=[],
      newEltIdx=0;

      
      newElt[newEltIdx++]='<div class="nGY2GThumbnail" style="display:none;opacity:0;" ><div class="nGY2GThumbnailSub">';

      var h=G.tn.defaultSize.getHeight(),
      w=G.tn.defaultSize.getWidth();

      newElt[newEltIdx++]='<div class="nGY2GThumbnailImage" style="width:'+w+'px;height:'+h+'px;"><img class="nGY2GThumbnailImg" src="'+G.emptyGif+'" alt="" style="max-width:'+w+'px;max-height:'+h+'px;" ></div>';

      
      newElt[newEltIdx++]= '<div class="nGY2GThumbnailAlbumUp" style="width:'+w+'px;height:'+h+'px;"></div>';
      
      newElt[newEltIdx++]='</div>';
      newElt[newEltIdx++]='</div>';
      
      var $newDiv =jQuery(newElt.join('')).appendTo(G.$E.conTn); //.animate({ opacity: 1},1000, 'swing');  //.show('slow'); //.fadeIn('slow').slideDown('slow');
      
      item.$elt=$newDiv;
      $newDiv.data('index',GOMidx);
      item.$getElt('.nGY2GThumbnailImg').data('index',GOMidx);
      
      return $newDiv;
    }
    
    function thumbnailBuild( item, idx, GOMidx ) {
      item.eltTransform=[];
      item.hoverInitDone=false;
      item.$Elts=[];

      if( item.kind == 'albumUp' ) {
        return { e$: ThumbnailBuildAlbumpUp( item, idx, GOMidx), cIS:false };
      }

      var newElt=[],
      newEltIdx=0;

      newElt[newEltIdx++]='<div class="nGY2GThumbnail" style="display:none;opacity:0;" ><div class="nGY2GThumbnailSub '+(G.O.thumbnailSelectable && item.selected?"nGY2GThumbnailSubSelected":"")+'">';
      
      var checkImageSize=false,
      src=G.emptyGif;

      if( ( G.layout.engine == 'CASCADING' && G.I[idx].thumbImg(G).height == 0) || ( G.layout.engine == 'JUSTIFIED' && G.I[idx].thumbImg(G).width == 0) ) {
        checkImageSize=true;
      }
      if( !G.O.thumbnailLazyLoad || checkImageSize) {
        src=item.thumbImg(G).src;
      }
      var sTitle=getThumbnailTitle(item),
      sDesc=getTumbnailDescription(item);
      
      if( G.layout.engine == 'CASCADING' ) {
        newElt[newEltIdx++]='<div class="nGY2GThumbnailImage" style="width:'+G.tn.settings.getW()+'px;"><img class="nGY2GThumbnailImg" src="'+src+'" alt="'+sTitle+'" style="max-width:'+G.tn.settings.getW()+'px;"></div>';
      }
      else if( G.layout.engine == 'JUSTIFIED' ) {
          newElt[newEltIdx++]='<div class="nGY2GThumbnailImage" style="height:'+G.tn.settings.getH()+'px;"><img class="nGY2GThumbnailImg" src="'+src+'" alt="'+sTitle+'" ></div>';
        }
        else {
          newElt[newEltIdx++]='<div class="nGY2GThumbnailImage" style="width:'+G.tn.settings.getW()+'px;height:'+G.tn.settings.getH()+'px;"><img class="nGY2GThumbnailImg" src="'+src+'" alt="'+sTitle+'" style="max-width:'+G.tn.settings.getW()+'px;max-height:'+G.tn.settings.getH()+'px;" ></div>';
        }
      // annotation (=area for labels + icons)
      if( G.O.thumbnailLabel.get('display') == true ) {
        // newElt[newEltIdx++]= '<div class="nGY2GThumbnailAnnotation" '+G.tn.style.getAnnotation()+'>';
        // Labels: title and description
        newElt[newEltIdx++]= '  <div class="nGY2GThumbnailLabel" '+ G.tn.style.getLabel(item) +'>';
        newElt[newEltIdx++]= '    <div class="nGY2GThumbnail'+(item.kind == 'album' ? 'Album' : 'Image')+'Title" '+G.tn.style.getTitle()+'>'+sTitle+'</div>';
        newElt[newEltIdx++]= '    <div class="nGY2GThumbnailDescription" '+G.tn.style.getDesc()+'>'+sDesc+'</div>';
        newElt[newEltIdx++]= '  </div>';
        // newElt[newEltIdx++]= '</div>';
      }
      
      // icons
      newElt[newEltIdx++]=ThumbnailBuildToolbar(item);
      
      newElt[newEltIdx++]='</div>';
      
      newElt[newEltIdx++]='</div>';
      
      // var $newDiv =jQuery(newElt.join('')).appendTo(G.$E.conTnHid); //.animate({ opacity: 1},1000, 'swing');  //.show('slow'); //.fadeIn('slow').slideDown('slow');
      var $newDiv =jQuery(newElt.join('')).appendTo(G.$E.conTn); //.animate({ opacity: 1},1000, 'swing');  //.show('slow'); //.fadeIn('slow').slideDown('slow');

      item.$elt=$newDiv;
      $newDiv.data('index',GOMidx);
      item.$getElt('.nGY2GThumbnailImg').data('index',GOMidx);
      // item.$getElt('img').data('index',idx);

      
      // Custom init function
      if( typeof G.O.fnThumbnailInit == 'function' ) { 
        G.O.fnThumbnailInit($newDiv, item, ExposedObjects());
      }

      if( item.title != 'dummydummydummy' ) {
        ThumbnailOverInit(GOMidx);
        ThumbnailOverResize(GOMidx);
      }
      
      return { e$:$newDiv, cIS:checkImageSize };
    }

    
    function ThumbnailBuildToolbar( item ) {
    
      var tb=ThumbnailBuildToolbarOne(item, 'topLeft');
      tb+=ThumbnailBuildToolbarOne(item, 'topRight');
      tb+=ThumbnailBuildToolbarOne(item, 'bottomLeft');
      tb+=ThumbnailBuildToolbarOne(item, 'bottomRight');

      return tb;
    
    }
    
    function ThumbnailBuildToolbarOne( item, position ) {
      var toolbar='';
      var tb=G.tn.toolbar.get(item);
      var width={ xs:0, sm:1, me:2, la:3, xl:4 };
      var cnt=0;
      
      if( tb[position] != '' ) {
//
        var pos='';
        switch( position ) {
          case 'topLeft':
            pos='top:0; left:0;';
            break;
          case 'bottomRight':
            pos='bottom:0; right:0;';
            break;
          case 'bottomLeft':
            pos='bottom:0; left:0;';
            break;
          case 'topRight':
          default:
            pos='top:0; right:0;';
            break;
        }
        
        toolbar+= '  <ul class="nGY2GThumbnailIcons" style="'+pos+'">';
        
        var icons=tb[position].split(',');
        var nb=icons.length;
        for( var i=0; i<nb; i++ ) {
          var icon=icons[i].replace(/^\s*|\s*$/, '');   //trim trailing/leading whitespace

          var minWidth=icon.substring(0,2).toLowerCase();
          var tIcon=icon;
          var display=true;
          if( /xs|sm|me|la|xl/i.test(minWidth) ) {
            // check visbility (depending on screen width)
            if( width[minWidth] > width[G.curWidth] ) {
              display=false;
            }
            tIcon=icon.substring(2);
          }
          
          if( display ) {
            var sp=(i+1<nb ? '&nbsp;' :'');
            switch( tIcon ) {
              case 'COUNTER':
                if( item.kind == 'album' ) {
                  toolbar+= '    <li class="nGY2GThumbnailIcon" data-action="">';
                  toolbar+= '      <div class="nGY2GThumbnailIconImageCounter"></div>';
                  toolbar+= '      <div class="nGY2GThumbnailIconText">'+Math.max((item.contentLength-1),item.numberItems)+sp+'</div>';
                  toolbar+= '    </li>';
                  cnt++;
                }
                break;
              case 'SHARE':
                toolbar+= '    <li class="nGY2GThumbnailIcon" data-action="'+tIcon+'">';
                toolbar+= '      <div class="nGY2GThumbnailIconImageShare"></div>';
                toolbar+= '      <div class="nGY2GThumbnailIconText">'+sp+'</div>';
                toolbar+= '    </li>';
                cnt++;
                break;
              case 'FEATURED':
                if( item.featured === true ) {
                  toolbar+= '    <li class="nGY2GThumbnailIcon" data-action="">';
                  toolbar+= '      <div class="nGY2GThumbnailIconImageFeatured"></div>';
                  toolbar+= '      <div class="nGY2GThumbnailIconText">'+sp+'</div>';
                  toolbar+= '    </li>';
                  cnt++;
                }
                break;
              case 'SELECT':
                if( G.O.thumbnailSelectable == true ) {
                  toolbar+= '    <li class="nGY2GThumbnailIcon" data-action="TOGGLESELECT">';
                  if( item.selected === true ) {
                    toolbar+= '      <div class="nGY2GThumbnailIconImageSelect nGY2ThumbnailSelected"></div>';
                  }
                  else {
                    toolbar+= '      <div class="nGY2GThumbnailIconImageSelect nGY2ThumbnailUnselected"></div>';
                  }
                  toolbar+= '      <div class="nGY2GThumbnailIconText">'+sp+'</div>';
                  toolbar+= '    </li>';
                  cnt++;
                }
                break;
            }
          }
        }
        toolbar+= '  </ul>';
      }
      
      if( cnt > 0 ) {
        return toolbar;
      }
      else {
        return '';
      }
    }
    
    function getThumbnailTitle( item ) {
    
      var sTitle=item.title;
      if( G.O.thumbnailLabel.get('display') == true ) {
        if( sTitle === undefined || sTitle.length == 0 ) { sTitle='&nbsp;'; }

        if( G.i18nTranslations.thumbnailImageTitle != '' ) {
          sTitle=G.i18nTranslations.thumbnailImageTitle;
        }
        if( G.O.thumbnailLabel.get('titleMaxLength') > 3 && sTitle.length > G.O.thumbnailLabel.get('titleMaxLength') ){
          sTitle=sTitle.substring(0,G.O.thumbnailLabel.get('titleMaxLength'))+'...';
        }
      }
      
      return sTitle;
    }

    function getTumbnailDescription( item ) {
      var sDesc='';
      if( G.O.thumbnailLabel.get('displayDescription') == true ) { 
        if( item.kind == 'album' ) {
          if( G.i18nTranslations.thumbnailImageDescription != '' ) {
            sDesc=G.i18nTranslations.thumbnailAlbumDescription;
          }
          else {
            sDesc=item.description;
          }
        }
        else {
          if( G.i18nTranslations.thumbnailImageDescription != '' ) {
            sDesc=G.i18nTranslations.thumbnailImageDescription;
          }
          else {
            sDesc=item.description;
          }
        }
        if( G.O.thumbnailLabel.get('descriptionMaxLength') > 3 && sDesc.length > G.O.thumbnailLabel.get('descriptionMaxLength') ){
          sDesc=sDesc.substring(0,G.O.thumbnailLabel.get('descriptionMaxLength'))+'...';
        }
        if( sDesc.length == 0 ) {
          sDesc='&nbsp;';
        }
      }
      
      return sDesc;
    }

    
    
    // Maximum number of thumbnails in one row
    function NbThumbnailsPerRow() {
    
      var tnW=G.tn.defaultSize.getOuterWidth();
      var areaW=G.$E.conTnParent.width();
      
      var nbMaxTn=0;
      if( G.O.thumbnailAlignment == 'justified' ) {
        nbMaxTn=Math.floor((areaW)/(tnW));
      }
      else {
        nbMaxTn=Math.floor((areaW+G.O.thumbnailGutterWidth)/(tnW+G.O.thumbnailGutterWidth));
      }
      
      if(  G.O.maxItemsPerLine >0 && nbMaxTn >  G.O.maxItemsPerLine ) {
        nbMaxTn=G.O.maxItemsPerLine;
      }
      
      if( nbMaxTn < 1 ) { nbMaxTn=1; }
      
      return nbMaxTn
    }
  
    function ThumbnailAppear( n, cnt ) {
      var curTn=G.GOM.items[n];
      var item=G.I[G.GOM.items[n].thumbnailIdx];

    
      if( G.O.thumbnailDisplayTransition === false || G.O.thumbnailDisplayTransition == 'NONE' ) {
        item.$elt.css({opacity:1});
      }
      else {
        // setTimeout(function() {
          // window.requestAnimationFrame( function() {
        if( item.$elt == null ) { return; }
        var top=G.GOM.cache.containerOffset.top+curTn.top;
        var vp=G.GOM.cache.viewport;
        if( (top+curTn.top) >= (vp.t-50) && top <= (vp.t+vp.h+50) ) {
          // display animation only if in the current viewport
          var delay=cnt*G.tn.displayInterval;
          switch( G.O.thumbnailDisplayTransition ) {
            case 'CUSTOM':
              G.O.fnThumbnailDisplayEffect(item.$elt, item, 0, delay);
              break;
            case 'SLIDEUP':
              ThumbnailAppearSlideUp(item, delay);
              break;
            case 'SLIDEDOWN':
              ThumbnailAppearSlideDown(item, delay);
              break;
            case 'SCALEDOWN':
              ThumbnailAppearScaleDown(item, delay);
              break;
            case 'SCALEUP':
              ThumbnailAppearScaleUp(item, delay);
              break;
            case 'FADEIN':
            default:
              ThumbnailAppearFadeIn(item, delay);
              break;
          }
        } else {
          item.$elt.css({opacity:1});
        }
          // });
        // }, cnt*G.tn.displayInterval);
      }
    }
    
    
    function ThumbnailAppearScaleUp( item, delay ) {
      var tweenable = new NGTweenable();
      tweenable.tween({
        from:     { scale: 0.8, opacity:0  },
        to:       { scale: 1, opacity:1 },
        attachment: { $e:item.$elt },
        delay: delay,
        duration: G.O.thumbnailDisplayTransitionDuration,
        easing: { opacity: 'easeInOutSine', scale:'easeOutQuart'},
        step: function (state, att) {
          att.$e.css( G.CSStransformName , 'scale('+state.scale+')').css('opacity',state.opacity);
        },
        finish: function (state, att) {
          att.$e.css( G.CSStransformName , '').css('opacity', '');
        }
      });
    }
    function ThumbnailAppearScaleDown( item, delay ) {
      var tweenable = new NGTweenable();
      tweenable.tween({
        from:     { 'scale': 1.1, 'opacity':0  },
        to:       { 'scale': 1, 'opacity':1 },
        attachment: { $e:item.$elt },
        delay: delay,
        duration: G.O.thumbnailDisplayTransitionDuration,
        easing: { opacity: 'easeInOutSine', scale:'easeOutQuart'},
        step: function (state, att) {
          att.$e.css( G.CSStransformName , 'scale('+state.scale+')').css('opacity',state.opacity);
        },
        finish: function (state, att) {
          att.$e.css( G.CSStransformName , '').css('opacity', '');
        }
      });
    }
    
    function ThumbnailAppearSlideUp( item, delay ) {
      var tweenable = new NGTweenable();
      tweenable.tween({
        from:     { 'opacity': 0, translateY:50, 'scale': 0.9  },
        to:       { 'opacity': 1, translateY: 0, 'scale': 1 },
        attachment: { $e:item.$elt },
        delay: delay,
        duration: G.O.thumbnailDisplayTransitionDuration,
        easing: { opacity: 'easeInOutSine', scale:'easeOutQuart', translateY:'easeOutQuart'},
        step: function (state, att) {
          att.$e.css( G.CSStransformName , 'translateY('+state.translateY+'px) scale('+state.scale+')').css('opacity',state.opacity);
        },
        finish: function (state, att) {
          att.$e.css( G.CSStransformName , '').css('opacity', '');
        }
      });
    }
    
    function ThumbnailAppearSlideDown( item, delay ) {
      var tweenable = new NGTweenable();
      tweenable.tween({
        from:     { opacity: 0, translateY:-50, scale: 0.9  },
        to:       { opacity: 1, translateY: 0, scale: 1 },
        attachment: { $e:item.$elt },
        delay: delay,
        duration: G.O.thumbnailDisplayTransitionDuration,
        easing: { opacity: 'easeInOutSine', scale:'easeOutQuart', translateY:'easeOutQuart'},
        step: function (state, att) {
          att.$e.css( G.CSStransformName , 'translateY('+state.translateY+'px) scale('+state.scale+')').css('opacity',state.opacity);
        },
        finish: function (state, att) {
          att.$e.css( G.CSStransformName , '').css('opacity', '');
        }
      });
    }

    function ThumbnailAppearFadeIn( item, delay ) {
      var tweenable = new NGTweenable();
      tweenable.tween({
        from:     { 'opacity': 0 },
        to:       { 'opacity': 1 },
        attachment: { $e:item.$elt },
        delay: delay,
        duration: G.O.thumbnailDisplayTransitionDuration,
        easing: 'easeInOutSine',
        step: function (state, att) {
          att.$e.css(state);
        },
        finish: function (state, att) {
          // att.$e.css('opacity', '');
          // att.$e.css({'opacity':1 });
        }
      });
    }


    // ######################################
    // ##### THUMBNAIL HOVER MANAGEMENT #####
    // ######################################

    function ThumbnailOverInit( GOMidx ) {
    //removeCSSTransform(item);
      
      var curTn=G.GOM.items[GOMidx];
      var item=G.I[curTn.thumbnailIdx];

      if( typeof G.O.fnThumbnailHoverInit == 'function' ) {
        G.O.fnThumbnailHoverInit($e, item, ExposedObjects() );
      }
      removeCSSTransform(item);

      var effects=G.tn.hoverEffects.get();
      for( var j=0; j<effects.length; j++) {
        switch( effects[j].name ) {
          case 'slideUp':
            item.$elt.css({overflow: 'hidden'});
            var $t=item.$getElt('.nGY2GThumbnailLabel');
            $t.css({opacity:1, top:0});
            newCSSTransform(item, 'nGY2GThumbnailLabel0',$t).translateY=curTn.height;
            SetCSSTransform(item, 'nGY2GThumbnailLabel0');
            // $t=item.$getElt('.imgContainer');
            // $t.css({left:0, top:0});
            // newCSSTransform(item, 'imgContainer0',$t);
            // SetCSSTransform(item, 'imgContainer0');
            break;
        }
      }
      
      item.hoverInitDone=true;
        
    }

    function ThumbnailOverResize( GOMidx ) {
      var curTn=G.GOM.items[GOMidx];
      var item=G.I[curTn.thumbnailIdx];
      if( item.kind == 'albumUp' ) { return; }
      if( !item.hoverInitDone ) {
        ThumbnailOverInit(GOMidx);
        return;
      }
      
      if( typeof G.O.fnThumbnailHoverResize == 'function' ) {
        G.O.fnThumbnailHoverResize($e, item, ExposedObjects() );
      }
      var effects=G.tn.hoverEffects.get();
      for( var j=0; j<effects.length; j++) {
        switch( effects[j].name ) {
          case 'slideUp':
            item.eltTransform['nGY2GThumbnailLabel0'].translateY=curTn.height;
            SetCSSTransform(item, 'nGY2GThumbnailLabel0');
            break;
        }
      }
      
    }
    
    function ThumbnailHover( GOMidx ) {
      var curTn=G.GOM.items[GOMidx];
      var item=G.I[curTn.thumbnailIdx];
      if( item.kind == 'albumUp' ) { return; }
      item.hovered=true;

      if( typeof G.O.fnThumbnailHover == 'function' ) { 
        G.O.fnThumbnailHover($e, item, ExposedObjects());
      }    
      
      var effects=G.tn.hoverEffects.get();
      try {
        for( var j=0; j<effects.length; j++) {
          switch(effects[j].name ) {
            case 'slideUp':
              // TnAni(item.$getElt('.imgContainer'), j, { translateY: -item.thumbFullHeight}, item, 'imgContainer0' );
              TnAni(item.$getElt('.nGY2GThumbnailLabel'), j, { translateY: 0}, item, 'nGY2GThumbnailLabel0' );
            break;
          }
        }
      }
      catch (e) { 
        NGY2Tools.nanoAlert(G, 'error on hover ' +e.message );
      }

    }

    function ThumbnailHoverOutAll() {
      var l=G.GOM.items.length;
      for( var i=0; i < l ; i++ ) {
        ThumbnailHoverOut(i);
      }
    }
    
    function ThumbnailHoverOut( GOMidx ) {
//      if( G.containerViewerDisplayed ) { return; }
      var curTn=G.GOM.items[GOMidx];
      var item=G.I[curTn.thumbnailIdx];
      if( item.kind == 'albumUp' || !item.hovered ) { return; }

      item.hovered=false;

      if( typeof G.O.fnThumbnailHoverOut == 'function' ) { 
        G.O.fnThumbnailHoverOut($e, item, ExposedObjects());
      }    

      var effects=G.tn.hoverEffects.get();
      try {
        for( var j=0; j<effects.length; j++) {
          switch( effects[j].name ) {
            case 'slideUp':
              // TnAniO(item.$getElt('.imgContainer'), j, { translateY: 0}, item, 'imgContainer0' );
              TnAniO(item.$getElt('.nGY2GThumbnailLabel'), j, { translateY: curTn.height}, item, 'nGY2GThumbnailLabel0' );
              break;
          }
        }
      }
      catch (e) { 
        NGY2Tools.nanoAlert(G, 'error on hoverOut ' +e.message );
      }
      
    }
    
    
    
    function newCSSTransform(item, eltClass, $e) {
      if( item.eltTransform[eltClass] == undefined ) {
        item.eltTransform[eltClass]=InitCSSTransform();
        item.eltTransform[eltClass].$elt=$e;
      }
      return item.eltTransform[eltClass];
    }
    
    function removeCSSTransform(item) {
       for (var p in item.eltTransform) {
          delete item.eltTransform[p];
       }
    }
    
    function InitCSSTransform() {
      var obj={translateX:0, translateY:0, rotateX:0, rotateY:0, rotateZ:0, scale:100};
      return obj;
    }
    
    function SetCSSTransform(item, objClass) {

      var obj=item.eltTransform[objClass];
      // var v = 'translateX('+obj.translateX+'px) translateY('+obj.translateY+'px)  scale('+obj.scale/100+')';
      var v = 'translateX('+obj.translateX+'px) translateY('+obj.translateY+'px) scale('+obj.scale/100+')';
      if( !(G.IE <= 9) && !G.isGingerbread ) {
        v += ' rotateX('+obj.rotateX+'deg) rotateY('+obj.rotateY+'deg) rotateZ('+obj.rotateZ+'deg)';
      }
      else {
        v += ' rotate('+obj.rotateZ+'deg)';
      }
      if( obj.$elt[0] != undefined ) {
        obj.$elt[0].style[G.CSStransformName]= v;
      }
    }    
    
    // ANIMATION OF ONE THUMBNAIL ELEMENT
    function TnAni( $e, n, anime, item, eltClass) {
//console.dir(item.eltTransform[eltClass]);        
      // STEP 1: animate CSS transform
      var transform=['translateX','translateY', 'scale', 'rotateX', 'rotateY', 'rotateZ'];
      for( var i=0; i<transform.length; i++ ) {
        var tf=transform[i];
        if( typeof  anime[tf] !== 'undefined' ) {
          var tweenable = new NGTweenable();
          var to=parseInt(anime[tf]);
          tweenable.tween({
            attachment: { it: item, eC: eltClass, t:tf, f:to},
            from: { 'v': parseInt(item.eltTransform[eltClass][tf])  },
            to: { 'v': to },
            duration: G.tn.hoverEffects.get()[n].duration,
            delay: G.tn.hoverEffects.get()[n].delay,
            easing: 'easeOutQuart',
            step: function (state, att) {
              if( att.it.hovered ) {
                att.it.eltTransform[att.eC][att.t]=state.v;
                SetCSSTransform(att.it, att.eC);
              }
            },
            finish: function (state, att) {
              if( att.it.hovered ) {
                att.it.eltTransform[att.eC][att.t]=att.f;
                SetCSSTransform(att.it, att.eC);
              }
            }
          });
          delete anime[tf];
        }
      }

      // is there something else to animate?
      var l = 0;
      for( var key in anime ) {
        if( anime.hasOwnProperty(key) ) {
          l++;
          break;
        }
      }      
      if( l == 0 ) {
        return;
      }
 
      // STEP 2: remaining animations
      // retrieve the 'from' values
      var fr={};
      for( var key in anime) {
        if( key == 'borderColor' ) {
          // borderColor is not supported in Firefox
          fr[key]=$e.css('borderTopColor');
        }
        else {
          fr[key]=$e.css(key);
        }
        if( fr[key] == 'transparent' ) {  // some browser return "transparent" as rgba(0,0,0,0), 
          if( $e.hasClass('labelImage') ) {
            fr[key]='rgb('+G.custGlobals.oldLabelRed+','+G.custGlobals.oldLabelGreen+','+G.custGlobals.oldLabelBlue+',0.01)';
          }
          else {
            fr[key]='rgba(0,0,0,0)';
          }
        }
      }
      var tweenable = new NGTweenable();
      tweenable.tween({
        attachment: { $e:$e, it:item, to:anime},
        from: fr,
        to: anime,
        duration: G.tn.hoverEffects.get()[n].duration,
        delay: G.tn.hoverEffects.get()[n].delay,
        easing: 'easeOutQuart',
        step: function (state, att) {
          if( att.it.hovered ) {
            att.$e.css(state);
          }
        },
        finish: function (state, att) {
          if( att.it.hovered ) {
            att.$e.css(anime);
          }
        }
      });
    }
        
    function TnAniO( $e, n, anime, item, eltClass) {
      
      // STEP 1: animate CSS transform
      var transform=['translateX', 'translateY', 'scale', 'rotateX', 'rotateY', 'rotateZ'];
      for( var i=0; i<transform.length; i++ ) {
        var tf=transform[i];
        if( typeof  anime[tf] !== 'undefined' ) {
          var tweenable = new NGTweenable();
          var to=parseInt(anime[tf]);
          tweenable.tween({
            attachment: { it: item, eC: eltClass, t:tf, f:to},
            from: { 'v': parseInt(item.eltTransform[eltClass][tf])  },
            to: { 'v': to },
            duration: G.tn.hoverEffects.get()[n].durationBack,
            delay: G.tn.hoverEffects.get()[n].delayBack,
            easing: 'easeOutQuart',
            step: function (state, att) {
              att.it.eltTransform[att.eC][att.t]=state.v;
              SetCSSTransform(att.it, att.eC);
            },
            finish: function (state, att) {
              att.it.eltTransform[att.eC][att.t]=att.f;
              SetCSSTransform(att.it, att.eC);
            }
          });
          delete anime[tf];
        }
      }
      
      // is there something else to animate?
      var l = 0;
      for( var key in anime ) {
        if( anime.hasOwnProperty(key) ) {
          l++;
          break;
        }
      }      
      if( l == 0 ) {
        return;
      }
 
      // STEP 2: remaining animations
      // retrieve the 'from' values
      var fr={};
      for( var key in anime) {
        if( key == 'borderColor' ) {
          // borderColor is not supported in Firefox
          fr[key]=$e.css('borderTopColor');
        }
        else {
          fr[key]=$e.css(key);
          if( fr[key] == 'transparent' ) {  // some browser return "transparent" as rgba(0,0,0,0)
            fr[key]='rgba(0,0,0,0.01)';
          }
        }
      }
      var tweenable = new NGTweenable();
      tweenable.tween({
        attachment: { $e:$e, it:item, to:anime},
        from: fr,
        to: anime,
        duration: G.tn.hoverEffects.get()[n].durationBack,
        delay: G.tn.hoverEffects.get()[n].delayBack,
        easing: 'easeOutQuart',
        step: function (state, att) {
          att.$e.css(state);
        },
        finish: function (state, att) {
          att.$e.css(att.to);
        }
      });
    }

    
    // ################################
    // #####                      #####
    // ################################

    function ElementTranslateX( element, posX ) {
      jQuery(element).css({ 'left': posX }); 
      
      // [TODO] - translateX needs some code refactoring...
      //var transformStyle = 'translateX('+posX+'px)';
      //element.style.msTransform = transformStyle;
      //element.style.MozTransform = transformStyle;
      //element.style.webkitTransform = transformStyle;
      //element.style.transform = transformStyle;
    }
    
    
    
    /** @function displayPhoto */
    function displayPhoto( imageID, albumID ) {
    
      var albumIdx=NGY2Item.GetIdx(G, albumID);
      
      if( NGY2Item.GetIdx(G, albumID) == -1 ) {
        NGY2Item.New( G, '', '', albumID, '0', 'album' );    // create empty album
        albumGetContent( '0', displayPhoto, imageID, albumID );
        return;
      }

      if( NGY2Item.GetIdx(G, imageID) == -1 ) {
        albumGetContent( albumID, displayPhoto, imageID, albumID );
        return;
      }
      
      alert('photo ok');
      // display viewer
      // set G.locationHashLastUsed if different then G.locationHashLastUsed
    
    }


    // Retrieve the title+description of ONE album
    function albumGetInfo( albumIdx, fnToCall ) {
      var url='';
      var kind='image';
      //var albumIdx=NGY2Item.GetIdx(G, ID);
      
      switch( G.O.kind ) {
        case 'json':
        case 'flickr':
        case 'picasa':
        default:
          url = G.picasa.url() + 'user/'+G.O.userID+'/albumid/'+G.I[albumIdx].GetID()+'?alt=json&&max-results=1&fields=title';
          break;
      }

      jQuery.ajaxSetup({ cache: false });
      jQuery.support.cors = true;
      
      var tId = setTimeout( function() {
        // workaround to handle JSONP (cross-domain) errors
        //PreloaderHide();
        NGY2Tools.nanoAlert(G, 'Could not retrieve AJAX data...');
      }, 60000 );
      jQuery.getJSON(url, function(data, status, xhr) {
        clearTimeout(tId);
        //PreloaderHide();
        
        fnToCall( G.I[albumIdx].GetID() );

      })
      .fail( function(jqxhr, textStatus, error) {
        clearTimeout(tId);
        //PreloaderHide();
        var err = textStatus + ', ' + error;
        NGY2Tools.nanoAlert(G, "Could not retrieve ajax data (jQuery): " + err);
      });      
    
    }

    
    // function albumGetContent( albumIdx, fnToCall ) {
    function albumGetContent( albumID, fnToCall, fnParam1, fnParam2 ) {
      var url='';
      var kind='image';
      var albumIdx=NGY2Item.GetIdx(G, albumID);
      // var photoIdx=NGY2Item.GetIdx(G, photoID);
      
      switch( G.O.kind ) {
        // MARKUP / API
        case '':
          break;
        // JSON, Flickr, Picasa, ...
        default:
          jQuery.nanoGallery2.data[G.O.kind](G, 'AlbumGetContent', albumID, fnToCall, fnParam1, fnParam2 );
      }
    }
    

   
    
    // ################################
    // #####                      #####
    // ################################

    
    /** @function defineVariables */
    function defineVariables() {

      // management of screen width
      G.curWidth=RetrieveCurWidth();

      // tumbnail toolbar
      jQuery.extend(true, G.tn.toolbar.image, G.O.thumbnailToolbarImage );
      jQuery.extend(true, G.tn.toolbar.album, G.O.thumbnailToolbarAlbum );
      G.tn.toolbar.image.topLeft=G.tn.toolbar.image.topLeft.toUpperCase();
      G.tn.toolbar.album.topLeft=G.tn.toolbar.album.topLeft.toUpperCase();
      G.tn.toolbar.image.topRight=G.tn.toolbar.image.topRight.toUpperCase();
      G.tn.toolbar.album.topRight=G.tn.toolbar.album.topRight.toUpperCase();
      G.tn.toolbar.image.bottomLeft=G.tn.toolbar.image.bottomLeft.toUpperCase();
      G.tn.toolbar.album.bottomLeft=G.tn.toolbar.album.bottomLeft.toUpperCase();
      G.tn.toolbar.image.bottomRight=G.tn.toolbar.image.bottomRight.toUpperCase();
      G.tn.toolbar.album.bottomRight=G.tn.toolbar.album.bottomRight.toUpperCase();

      // thumbnails label - level dependant settings
//TODO --> following move to G.tn
      G.O.thumbnailLabel.get = function( opt ) {
        if( G.curNavLevel == 'l1' && G.O.thumbnailL1Label !== undefined && G.O.thumbnailL1Label[opt] !== undefined ) {
          return G.O.thumbnailL1Label[opt];
        }
        else {
          return G.O.thumbnailLabel[opt];
        }
      };
      G.O.thumbnailLabel.set = function( opt, value ) {
        if( G.curNavLevel == 'l1' && G.O.thumbnailL1Label !== undefined && G.O.thumbnailL1Label[opt] !== undefined ) {
          G.O.thumbnailL1Label[opt]=value;
        }
        else {
          G.O.thumbnailLabel[opt]=value;
        }
      };

      if( G.O.blackList != '' ) { G.blackList=G.O.blackList.toUpperCase().split('|'); }
      if( G.O.whiteList != '' ) { G.whiteList=G.O.whiteList.toUpperCase().split('|'); }
      if( G.O.albumList != '' ) { G.albumList=G.O.albumList.toUpperCase().split('|'); }

      G.O.galleryDisplayMode=G.O.galleryDisplayMode.toUpperCase();
      G.O.galleryPaginationMode=G.O.galleryPaginationMode.toUpperCase();
      if( typeof G.O.thumbnailDisplayTransition == 'boolean' ) {
        if( G.O.thumbnailDisplayTransition === true ) {
          G.O.thumbnailDisplayTransition='FADEIN';
        }
        else {
          G.O.thumbnailDisplayTransition='NONE';
        }
      }
      else {
        G.O.thumbnailDisplayTransition=G.O.thumbnailDisplayTransition.toUpperCase();
      }
      if( typeof G.O.fnThumbnailDisplayEffect == 'function' ) {
        G.O.thumbnailDisplayTransition='CUSTOM';
      }

      
      if( toType(G.O.paginationMaxLinesPerPage) == 'number' && G.O.paginationMaxLinesPerPage >= 0 ) {
        G.pgMaxLinesPerPage=G.O.paginationMaxLinesPerPage;
      }
      else {
        nanoConsoleLog('Parameter "paginationMaxLinesPerPage" must be an integer.');
      }

      if( toType(G.O.slideshowDelay) == 'number' && G.O.slideshowDelay >= 2000 ) {
        G.slideshowDelay=G.O.slideshowDelay;
      }
      else {
        nanoConsoleLog('Parameter "slideshowDelay" must be an integer >= 2000 ms.');
      }

      if( toType(G.O.thumbnailDisplayInterval) == 'number' && G.O.thumbnailDisplayInterval >= 0 ) {
        G.tn.displayInterval=G.O.thumbnailDisplayInterval;
      }
      else {
        nanoConsoleLog('Parameter "thumbnailDisplayInterval" must be an integer.');
      }



      // resolution breakpoints --> convert old syntax to new one
      if( G.O.thumbnailSizeSM !== undefined ) { G.O.breakpointSizeSM=G.O.thumbnailSizeSM; }
      if( G.O.thumbnailSizeME !== undefined ) { G.O.breakpointSizeME=G.O.thumbnailSizeME; }
      if( G.O.thumbnailSizeLA !== undefined ) { G.O.breakpointSizeLA=G.O.thumbnailSizeLA; }
      if( G.O.thumbnailSizeXL !== undefined ) { G.O.breakpointSizeXL=G.O.thumbnailSizeXL; }


      // THUMBNAIL HOVER EFFETCS
      
      // thumbnails hover effects - Level1
      var tL1HE=G.O.thumbnailL1HoverEffect;
      if( tL1HE !== undefined ) {
        switch( toType(tL1HE) ) {
          case 'string':
            var tmp=tL1HE.split(',');
            for(var i=0; i<tmp.length; i++) {
              if( tmp[i] != 'none' && isAEngineSupported(tmp[i]) ) {
                var oDef=NewTHoverEffect();
                oDef.name=tmp[i];
                G.tn.hoverEffects.level1.push(oDef);
              }
            }
            break;
          case 'object':
            if( tL1HE.name != 'none' && isAEngineSupported(tL1HE.name) ) {
              var oDef=NewTHoverEffect();
              G.tn.hoverEffects.level1.push(jQuery.extend(oDef,tL1HE));
            }
            break;
          case 'array':
            for(var i=0; i<tL1HE.length; i++) {
              if( tL1HE[i].name != 'none' ) {
                var oDef=NewTHoverEffect();
                G.tn.hoverEffects.level1.push(jQuery.extend(oDef,tL1HE[i]));
              }
            }
            break;
          case 'null':
            break;
          default:
            NGY2Tools.nanoAlert(G, 'incorrect parameter for "thumbnailL1HoverEffect".');
        }
      }
      
      // thumbnails hover effects - other levels
      var tHE=G.O.thumbnailHoverEffect;
      switch( toType(tHE) ) {
        case 'string':
          var tmp=tHE.split(',');
          for(var i=0; i<tmp.length; i++) {
            if( tmp[i] != 'none' && isAEngineSupported(tmp[i]) ) {
              var oDef=NewTHoverEffect();
              oDef.name=tmp[i];
              G.tn.hoverEffects.std.push(oDef);
            }
          }
          break;
        case 'object':
          if( tHE.name != 'none' && isAEngineSupported(tHE.name) ) {
            var oDef=NewTHoverEffect();
            G.tn.hoverEffects.std.push(jQuery.extend(oDef,tHE));
          }
          break;
        case 'array':
          for(var i=0; i<tHE.length; i++) {
            if( tHE[i].name != 'none' ) {
              var oDef=NewTHoverEffect();
              G.tn.hoverEffects.std.push(jQuery.extend(oDef,tHE[i]));
            }
          }
          break;
        case 'null':
          break;
        default:
          NGY2Tools.nanoAlert(G, 'incorrect parameter for "thumbnailHoverEffect".');
      }

      
      if( G.tn.hoverEffects.std.length == 0 ) {
        if( G.tn.hoverEffects.level1.length == 0 ) {
          G.O.touchAnimationL1=false;
        }
        G.O.touchAnimation=false;
      }      
      
      
      // RETRIEVE ALL THUMBNAIL SIZES
      if( toType(G.O.thumbnailWidth) == 'number' ) {
        ThumbnailsSetSize( 'width', 'l1', G.O.thumbnailWidth, 'u');
        ThumbnailsSetSize( 'width', 'lN', G.O.thumbnailWidth, 'u');
      }
      else {
        var ws=G.O.thumbnailWidth.split(' ');
        var v='auto';
        if( ws[0].substring(0,4) != 'auto' ) { v=parseInt(ws[0]); }
        var c='u';
        if( ws[0].charAt(ws[0].length - 1) == 'C' ) { c='c'; }
        ThumbnailsSetSize( 'width', 'l1', v, c );   // default value for all resolutions and navigation levels
        ThumbnailsSetSize( 'width', 'lN', v, c );
        for( var i=1; i<ws.length; i++ ) {
          var r=ws[i].substring(0,2).toLowerCase();
          if( /xs|sm|me|la|xl/i.test(r) ) {
            var w=ws[i].substring(2);
            var v='auto';
            if( w.substring(0,4) != 'auto' ) { v=parseInt(w); }
            var c='u';
            if( w.charAt(w.length - 1) == 'C' ) { c='c'; }
            G.tn.settings.width['l1'][r]=v;
            G.tn.settings.width['lN'][r]=v;
            G.tn.settings.width['l1'][r+'c']=c;
            G.tn.settings.width['lN'][r+'c']=c;
          }
        }
      }
      if( G.O.thumbnailL1Width != undefined ) {
        if( toType(G.O.thumbnailL1Width) == 'number' ) {
          ThumbnailsSetSize( 'width', 'l1', G.O.thumbnailL1Width, 'u');
        }
        else {
          var ws=G.O.thumbnailL1Width.split(' ');
          var v='auto';
          if( ws[0].substring(0,4) != 'auto' ) { v=parseInt(ws[0]); }
          var c='u';
          if( ws[0].charAt(ws[0].length - 1) == 'C' ) { c='c'; }
          ThumbnailsSetSize( 'width', 'l1', v, c );
          for( var i=1; i<ws.length; i++ ) {
            var r=ws[i].substring(0,2).toLowerCase();
            if( /xs|sm|me|la|xl/i.test(r) ) {
              var w=ws[i].substring(2);
              var v='auto';
              if( w.substring(0,4) != 'auto' ) { v=parseInt(w); }
              var c='u';
              if( w.charAt(w.length - 1) == 'C' ) { c='c'; }
              G.tn.settings.width['l1'][r]=v;
              G.tn.settings.width['l1'][r+'c']=c;
            }
          }
        }
      }

      if( toType(G.O.thumbnailHeight) == 'number' ) {
        ThumbnailsSetSize( 'height', 'l1', G.O.thumbnailHeight, 'u');
        ThumbnailsSetSize( 'height', 'lN', G.O.thumbnailHeight, 'u');
      }
      else {
        var ws=G.O.thumbnailHeight.split(' ');
        var v='auto';
        if( ws[0].substring(0,4) != 'auto' ) { v=parseInt(ws[0]); }
        var c='u';
        if( ws[0].charAt(ws[0].length - 1) == 'C' ) { c='c'; }
        ThumbnailsSetSize( 'height', 'l1', v, c );   // default value for all resolutions and navigation levels
        ThumbnailsSetSize( 'height', 'lN', v, c );
        for( var i=1; i<ws.length; i++ ) {
          var r=ws[i].substring(0,2).toLowerCase();
          if( /xs|sm|me|la|xl/i.test(r) ) {
            var w=ws[i].substring(2);
            var v='auto';
            if( w.substring(0,4) != 'auto' ) { v=parseInt(w); }
            var c='u';
            if( w.charAt(w.length - 1) == 'C' ) { c='c'; }
            G.tn.settings.height['l1'][r]=v;
            G.tn.settings.height['lN'][r]=v;
            G.tn.settings.height['l1'][r+'c']=c;
            G.tn.settings.height['lN'][r+'c']=c;
          }
        }
      }
      if( G.O.thumbnailL1Height != undefined ) {
        if( toType(G.O.thumbnailL1Height) == 'number' ) {
          ThumbnailsSetSize( 'height', 'l1', G.O.thumbnailL1Height, 'u');
        }
        else {
          var ws=G.O.thumbnailL1Height.split(' ');
          var v='auto';
          if( ws[0].substring(0,4) != 'auto' ) { v=parseInt(ws[0]); }
          var c='u';
          if( ws[0].charAt(ws[0].length - 1) == 'C' ) { c='c'; }
          ThumbnailsSetSize( 'height', 'l1', v, c );
          for( var i=1; i<ws.length; i++ ) {
            var r=ws[i].substring(0,2).toLowerCase();
            if( /xs|sm|me|la|xl/i.test(r) ) {
              var w=ws[i].substring(2);
              var v='auto';
              if( w.substring(0,4) != 'auto' ) { v=parseInt(w); }
              var c='u';
              if( w.charAt(w.length - 1) == 'C' ) { c='c'; }
              G.tn.settings.height['l1'][r]=v;
              G.tn.settings.height['l1'][r+'c']=c;
            }
          }
        }
      }
      
      G.O.thumbnailBorderHorizontal=parseInt(G.O.thumbnailBorderHorizontal);
      G.O.thumbnailBorderVertical=parseInt(G.O.thumbnailBorderVertical);
      G.O.thumbnailLabelHeight=parseInt(G.O.thumbnailLabelHeight);

      G.layout.SetEngine();
      
      // init plugins
      switch( G.O.kind ) {
        // MARKUP / API
        case '':
          break;
        // JSON, Flickr, Picasa, ...
        default:
          jQuery.nanoGallery2.data[G.O.kind](G, 'Init' );
      }

    }

    // HOVER EFFECTS
    function NewTHoverEffect() {
      // easing : jQuery supports only 'swing' and 'linear'
      var oDef={'delay':0, 'delayBack':0, 'duration':400, 'durationBack':200, 'easing':'ease', 'easingBack': 'ease', 'animParam':null };
      return oDef;
    }

    
        // build a dummy thumbnail to get different sizes and to cache them
    function ThumbnailDefCaches() {
      
            // thumbnail content CSS styles
      // if( G.O.thumbnailLabel.display ) {
        switch( G.O.thumbnailLabel.position ){
          case 'onBottom' :
            G.tn.style.lN.annotation='top:0; position:relative;';
            G.tn.style.l1.annotation='top:0; position:relative;';
            if( G.layout.engine == 'CASCADING' ) {
              // line break --> title and description can be multi-line
              G.tn.style.lN.label='top:auto; bottom:0; position:relative;';
              G.tn.style.l1.label='top:auto; bottom:0; position:relative;';
              // G.tn.style.lN.title='white-space:normal;';
              // G.tn.style.l1.title='white-space:normal;';
              // G.tn.style.lN.desc='white-space:normal;';
              // G.tn.style.l1.desc='white-space:normal;';
              if( G.O.thumbnailLabel.titleMultiLine ) {
                G.tn.style.lN.title='white-space:normal;';
                G.tn.style.l1.title='white-space:normal;';
              }
              if( G.O.thumbnailLabel.descriptionMultiLine ) {
                G.tn.style.lN.desc='white-space:normal;';
                G.tn.style.l1.desc='white-space:normal;';
              }
            }
            else {
              // no line break -> title and description cannot be multi-line
              // G.tn.style.lN.title='white-space:nowrap;';
              // G.tn.style.l1.title='white-space:nowrap;';
              // G.tn.style.lN.desc='white-space:nowrap;';
              // G.tn.style.l1.desc='white-space:nowrap;';
            }
            break;
          case 'overImageOnTop' :
            G.tn.style.lN.annotation='top:0; bottom:0;';
            G.tn.style.l1.annotation='top:0; bottom:0;';
            G.tn.style.l1.label='top:0; position:absolute;';
            G.tn.style.lN.label='top:0; position:absolute;';
            if( G.O.thumbnailLabel.titleMultiLine ) {
              G.tn.style.lN.title='white-space:normal;';
              G.tn.style.l1.title='white-space:normal;';
            }
            if( G.O.thumbnailLabel.descriptionMultiLine ) {
              G.tn.style.lN.desc='white-space:normal;';
              G.tn.style.l1.desc='white-space:normal;';
            }
            break;
          case 'overImageOnMiddle' :
            G.tn.style.lN.annotation='top:0; bottom:0;';
            G.tn.style.lN.label='top:0; bottom:0;';
            G.tn.style.l1.annotation='top:0; bottom:0;';
            G.tn.style.l1.label='top:0; bottom:0;';
            G.tn.style.lN.title='position:absolute; bottom:50%;';
            G.tn.style.l1.title='position:absolute; bottom:50%;';
            G.tn.style.lN.desc='position:absolute; top:50%;';
            G.tn.style.l1.desc='position:absolute; top:50%;';
            if( G.O.thumbnailLabel.titleMultiLine ) {
              G.tn.style.lN.title+='white-space:normal;';
              G.tn.style.l1.title+='white-space:normal;';
            }
            if( G.O.thumbnailLabel.descriptionMultiLine ) {
              G.tn.style.lN.desc+='white-space:normal;';
              G.tn.style.l1.desc+='white-space:normal;';
            }
            break;
          case 'custom' :
            break;
          case 'overImageOnBottom' :
          default :
            G.O.thumbnailLabel.position='overImageOnBottom';
            G.tn.style.lN.annotation='bottom:0;';
            G.tn.style.lN.label='bottom:0; position:absolute;';
            G.tn.style.l1.annotation='bottom:0;';
            G.tn.style.l1.label='bottom:0; position:absolute;';
            if( G.O.thumbnailLabel.titleMultiLine ) {
              G.tn.style.lN.title='white-space:normal;';
              G.tn.style.l1.title='white-space:normal;';
            }
            if( G.O.thumbnailLabel.descriptionMultiLine ) {
              G.tn.style.lN.desc='white-space:normal;';
              G.tn.style.l1.desc='white-space:normal;';
            }
            break;
        }
      // }
      if( G.O.thumbnailL1Label && G.O.thumbnailL1Label.display ) {
        switch( G.O.thumbnailL1Label.position ){
          case 'onBottom' :
            G.tn.style.l1.annotation='top:0; position:relative;';
            if( G.layout.engine == 'CASCADING' ) {
              // line break
              G.tn.style.l1.label='top:auto; bottom:0;';
              // G.tn.style.l1.title='white-space:normal;';
              // G.tn.style.l1.desc='white-space:normal;';
              if( G.O.thumbnailL1Label.titleMultiLine ) {
                G.tn.style.l1.title='white-space:normal;';
              }
              if( G.O.thumbnailL1Label.descriptionMultiLine ) {
                G.tn.style.l1.desc='white-space:normal;';
              }
            }
            else {
              // no line break
              // G.tn.style.l1.title='white-space:nowrap;';
              // G.tn.style.l1.desc='white-space:nowrap;';
            }
            break;
          case 'overImageOnTop' :
            G.tn.style.l1.annotation='top:0; bottom:0;';
            G.tn.style.l1.label='top:0; bottom:0;';
            if( G.O.thumbnailL1Label.titleMultiLine ) {
              G.tn.style.l1.title='white-space:normal;';
            }
            if( G.O.thumbnailL1Label.descriptionMultiLine ) {
              G.tn.style.l1.desc='white-space:normal;';
            }
            break;
          case 'overImageOnMiddle' :
            G.tn.style.l1.annotation='top:0; bottom:0;';
            G.tn.style.l1.label='top:0; bottom:0;';
            G.tn.style.l1.title='position:absolute; bottom:50%;';
            G.tn.style.l1.desc='position:absolute; top:50%;';
            if( G.O.thumbnailL1Label.titleMultiLine ) {
              G.tn.style.l1.title+='white-space:normal;';
            }
            if( G.O.thumbnailL1Label.descriptionMultiLine ) {
              G.tn.style.l1.desc+='white-space:normal;';
            }
            break;
          case 'custom' :
            G.tn.style.l1.annotation='';
            if( G.O.thumbnailL1Label.titleMultiLine ) {
              G.tn.style.l1.title='white-space:normal;';
            }
            if( G.O.thumbnailL1Label.descriptionMultiLine ) {
              G.tn.style.l1.desc='white-space:normal;';
            }
            break;
          case 'overImageOnBottom':
          default :
            G.O.thumbnailL1Label.position='overImageOnBottom';
            G.tn.style.l1.annotation='bottom:0;';
            G.tn.style.l1.label='bottom:0;';
            if( G.O.thumbnailL1Label.titleMultiLine ) {
              G.tn.style.l1.title='white-space:normal;';
            }
            if( G.O.thumbnailL1Label.descriptionMultiLine ) {
              G.tn.style.l1.desc='white-space:normal;';
            }
            break;
        }
      }
      
      
      
      G.tn.borderWidth=G.O.thumbnailBorderHorizontal;
      G.tn.borderHeight=G.O.thumbnailBorderVertical;
      
      
      // Retrieve info for level LN
      // TODO: do this only for grid layout and label onBottom

      // retrieve annotation (label+description) height -> now done on every gallery render for the most accurate value
      // if( G.O.thumbnailLabel.get('position') == 'onBottom' ) {
      //  G.curNavLevel='lN';
      //  var lh=ThumbnailGetAnnotationHeight()
      //  G.tn.labelHeight.lN= lh;
      //  G.tn.labelHeight.l1= lh;
      //  G.curNavLevel='l1';
      //}

      // default thumbnail sizes levels l1 and lN
      var lst=['xs','sm','me','la','xl'];
      for( var i=0; i< lst.length; i++ ) {
        var w=G.tn.settings.width['lN'][lst[i]];
        // w=G.tn.settings.width['l1'][lst[i]];
        if( w != 'auto' ) {
          G.tn.defaultSize.width['lN'][lst[i]]=w;
          G.tn.defaultSize.width['l1'][lst[i]]=w;
        }
        else {
          // G.tn.outerWidth['lN'][lst[i]]=0;      // dynamic width
          // G.tn.outerWidth['l1'][lst[i]]=0;      // dynamic width
          var h=G.tn.settings.height['lN'][lst[i]];
          G.tn.defaultSize.width['lN'][lst[i]]=h;      // dynamic width --> set height value as default
          G.tn.defaultSize.width['l1'][lst[i]]=h;      // dynamic width --> set height value as default
        }
      }
      for( var i=0; i< lst.length; i++ ) {
        var h=G.tn.settings.height['lN'][lst[i]];
        // h=G.tn.settings.height['l1'][lst[i]];
        if( h != 'auto' ) {
          // grid or justified layout
          G.tn.defaultSize.height['lN'][lst[i]]=h;  //+G.tn.labelHeight.get();
          G.tn.defaultSize.height['l1'][lst[i]]=h;  //+G.tn.labelHeight.get();
        }
        else {
          // G.tn.outerHeight['lN'][lst[i]]=0;      // dynamic height
          // G.tn.outerHeight['l1'][lst[i]]=0;      // dynamic height
          var w=G.tn.settings.width['lN'][lst[i]];
          G.tn.defaultSize.height['lN'][lst[i]]=w;      // dynamic height --> set width value as default
          G.tn.defaultSize.height['l1'][lst[i]]=w;      // dynamic height --> set width value as default
        }
      }


      // Retrieve info for level L1
      // TODO: do this only for grid layout and label onBottom
      // if( G.O.thumbnailLabel.get('position') == 'onBottom' ) {
      //   G.curNavLevel='l1';
      //   var lh=ThumbnailGetAnnotationHeight()
      //   // G.tn.labelHeight.l1= $newDiv.find('.nGY2GThumbnailLabel').outerHeight(true);
      //   G.tn.labelHeight.l1= lh;
      // }
      
      
      // default thumbnail sizes levels l1 and lN
      var lst=['xs','sm','me','la','xl'];
      for( var i=0; i< lst.length; i++ ) {
        var w=G.tn.settings.width['l1'][lst[i]];
        if( w != 'auto' ) {
          G.tn.defaultSize.width['l1'][lst[i]]=w;
        }
        else {
          // G.tn.outerWidth['l1'][lst[i]]=0;
          var h=G.tn.settings.height['l1'][lst[i]];
          G.tn.defaultSize.width['l1'][lst[i]]=h;      // dynamic width --> set height value as default
        }
      }
      for( var i=0; i< lst.length; i++ ) {
        var h=G.tn.settings.height['l1'][lst[i]];
        if( h != 'auto' ) {
          // grid or justified layout
          G.tn.defaultSize.height['l1'][lst[i]]=h;  //+G.tn.labelHeight.get();
        }
        else {
          // G.tn.outerHeight['l1'][lst[i]]=0;
          var w=G.tn.settings.width['l1'][lst[i]];
          G.tn.defaultSize.height['l1'][lst[i]]=w;      // dynamic height --> set width value as default
        }
      }
      
    }
    

    // ##### THUMBNAIL SIZE MANAGEMENT
    function ThumbnailsSetSize( dir, level, v, crop ) {
      G.tn.settings[dir][level]['xs']=v;
      G.tn.settings[dir][level]['sm']=v;
      G.tn.settings[dir][level]['me']=v;
      G.tn.settings[dir][level]['la']=v;
      G.tn.settings[dir][level]['xl']=v;
      G.tn.settings[dir][level]['xsc']=crop;
      G.tn.settings[dir][level]['smc']=crop;
      G.tn.settings[dir][level]['mec']=crop;
      G.tn.settings[dir][level]['lac']=crop;
      G.tn.settings[dir][level]['xlc']=crop;
    }


        // ##### BREADCRUMB/THUMBNAIL COLOR SCHEME #####
    function SetColorScheme() {
      var cs=null;
      switch(toType(G.O.colorScheme)) {
        case 'object':    // user custom color scheme object 
          cs=G.colorScheme_default;
          jQuery.extend(true,cs,G.O.colorScheme);
          G.colorSchemeLabel='nanogallery_colorscheme_custom_'+G.baseEltID;
          break;
        case 'string':    // name of an internal defined color scheme
          switch( G.O.colorScheme ) {
            case 'light':
              cs=G.colorScheme_light;
              G.colorSchemeLabel='nanogallery_colorscheme_light';
              break;
            case 'lightBackground':
              cs=G.colorScheme_lightBackground;
              G.colorSchemeLabel='nanogallery_colorscheme_lightBackground';
              break;
            case 'darkRed':
              cs=G.colorScheme_darkRed;
              G.colorSchemeLabel='nanogallery_colorscheme_darkred';
              break;
            case 'darkGreen':
              cs=G.colorScheme_darkGreen;
              G.colorSchemeLabel='nanogallery_colorscheme_darkgreen';
              break;
            case 'darkBlue':
              cs=G.colorScheme_darkBlue;
              G.colorSchemeLabel='nanogallery_colorscheme_darkblue';
              break;
            case 'darkOrange':
              cs=G.colorScheme_darkOrange;
              G.colorSchemeLabel='nanogallery_colorscheme_darkorange';
              break;
            case 'default':
            case 'dark':
            case 'none':
            default:
              cs=G.colorScheme_default;
              G.colorSchemeLabel='nanogallery_colorscheme_default';
          }
          break;
        default:
          NGY2Tools.nanoAlert(G, 'Error in colorScheme parameter.');
          return;
      }

      //var s1='.nanogallery_theme_'+G.O.theme+' ';
      var s1='.' + G.colorSchemeLabel + ' ';
      var s=s1+'.nGY2tDNavigationbar { background:'+cs.navigationbar.background+' !important; }'+'\n';
      if( cs.navigationbar.border !== undefined ) { s+=s1+'.nGY2tDNavigationbar { border:'+cs.navigationbar.border+' !important; }'+'\n'; }
      if( cs.navigationbar.borderTop !== undefined ) { s+=s1+'.nGY2tDNavigationbar { border-top:'+cs.navigationbar.borderTop+' !important; }'+'\n'; }
      if( cs.navigationbar.borderBottom !== undefined ) { s+=s1+'.nGY2tDNavigationbar { border-bottom:'+cs.navigationbar.borderBottom+' !important; }'+'\n'; }
      if( cs.navigationbar.borderRight !== undefined ) { s+=s1+'.nGY2tDNavigationbar { border-right:'+cs.navigationbar.borderRight+' !important; }'+'\n'; }
      if( cs.navigationbar.borderLeft !== undefined ) { s+=s1+'.nGY2tDNavigationbar { border-left:'+cs.navigationbar.borderLeft+' !important; }'+'\n'; }
      s+=s1+'.nGY2tDNavigationbar .oneFolder  { color:'+cs.navigationbar.color+' !important; }'+'\n';
      s+=s1+'.nGY2tDNavigationbar .separator  { color:'+cs.navigationbar.color+' !important; }'+'\n';
      s+=s1+'.nGY2tDNavigationbar .separatorRTL  { color:'+cs.navigationbar.color+' !important; }'+'\n';
      s+=s1+'.nGY2tDNavigationbar .oneFolder:hover { color:'+cs.navigationbar.colorHover+' !important; }'+'\n';
      s+=s1+'.nGY2tDNavigationbar .separatorRTL:hover { color:'+cs.navigationbar.colorHover+' !important; }'+'\n';

      // thumbnails
      s+=s1+'.nGY2GThumbnail { background:'+cs.thumbnail.background+'; border-color:'+cs.thumbnail.borderColor+'; border-top-width:'+G.O.thumbnailBorderVertical+'px; border-right-width:'+G.O.thumbnailBorderHorizontal+'px; border-bottom-width:'+G.O.thumbnailBorderVertical+'px; border-left-width:'+G.O.thumbnailBorderHorizontal+'px;}'+'\n';
      s+=s1+'.nGY2GThumbnailImage { background:'+cs.thumbnail.background+'; }'+'\n';
      s+=s1+'.nGY2GThumbnailAlbumUp { background:'+cs.thumbnail.background+'; }'+'\n';
      s+=s1+'.nGY2GThumbnailLabel { background:'+cs.thumbnail.labelBackground+'; opacity:'+cs.thumbnail.labelOpacity+'; }'+'\n';
      s+=s1+'.nGY2GThumbnailImageTitle  { color:'+cs.thumbnail.titleColor+'; '+(cs.thumbnail.titleShadow =='' ? '': 'Text-Shadow:'+cs.thumbnail.titleShadow)+'; }'+'\n';
      s+=s1+'.nGY2GThumbnailImageTitle:before { color:'+cs.thumbnail.titleColor+'; '+(cs.thumbnail.titleShadow =='' ? '': 'Text-Shadow:'+cs.thumbnail.titleShadow)+'; }'+'\n';
      s+=s1+'.nGY2GThumbnailAlbumTitle { color:'+cs.thumbnail.titleColor+'; '+(cs.thumbnail.titleShadow =='' ? '': 'Text-Shadow:'+cs.thumbnail.titleShadow)+'; }'+'\n';
      s+=s1+'.nGY2GThumbnailAlbumTitle:before { color:'+cs.thumbnail.titleColor+'; '+(cs.thumbnail.titleShadow =='' ? '': 'Text-Shadow:'+cs.thumbnail.titleShadow)+'; }'+'\n';
      s+=s1+'.nGY2GThumbnailDescription { color:'+cs.thumbnail.descriptionColor+'; '+(cs.thumbnail.descriptionShadow =='' ? '': 'Text-Shadow:'+cs.thumbnail.descriptionShadow)+'; }'+'\n';

      // gallery pagination -> dot/rectangle based
      if( G.O.galleryPaginationMode != 'NUMBERS' ) {
        s+=s1+'.nGY2paginationDot { border:'+cs.thumbnail.paginationShapeBorder+'; background:'+cs.thumbnail.paginationShapeBack+';}'+'\n';
        s+=s1+'.nGY2paginationDotCurrentPage { border:'+cs.thumbnail.paginationShapeBorder+'; background:'+cs.thumbnail.paginationShapeSelBack+';}'+'\n';
        s+=s1+'.nGY2paginationRectangle { border:'+cs.thumbnail.paginationShapeBorder+'; background:'+cs.thumbnail.paginationShapeBack+';}'+'\n';
        s+=s1+'.nGY2paginationRectangleCurrentPage { border:'+cs.thumbnail.paginationShapeBorder+'; background:'+cs.thumbnail.paginationShapeSelBack+';}'+'\n';
      }
      
      // gallery more button
      s+=s1+'.nGY2GalleryMoreButtonAnnotation { background:'+cs.thumbnail.background+'; border-color:'+cs.thumbnail.borderColor+'; border-top-width:'+G.O.thumbnailBorderVertical+'px; border-right-width:'+G.O.thumbnailBorderHorizontal+'px; border-bottom-width:'+G.O.thumbnailBorderVertical+'px; border-left-width:'+G.O.thumbnailBorderHorizontal+'px;}'+'\n';
      s+=s1+'.nGY2GalleryMoreButtonAnnotation  { color:'+cs.thumbnail.titleColor+'; '+(cs.thumbnail.titleShadow =='' ? '': 'Text-Shadow:'+cs.thumbnail.titleShadow)+'; }'+'\n';
      
      // gallery fullpage background color
      var gbg='nanogallery_galleryfullpage_bgcolor_'+G.baseEltID;
      s+='.' + gbg +'.fullpage { background:'+G.O.galleryFullpageBgColor+' !important; }'+'\n';

      G.currColorScheme=cs;
      
      jQuery('head').append('<style>'+s+'</style>');
      jQuery(G.$E.base).addClass(G.colorSchemeLabel);
      jQuery(G.$E.base).addClass(gbg);

    };
    
    
    /** @function setPolyFills */
    function setPolyFills() {

      // POLYFILL FOR BIND function --> for older Safari mobile
      // found on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
      if (!Function.prototype.bind) {
        Function.prototype.bind = function (oThis) {
          if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
          }

          var aArgs = Array.prototype.slice.call(arguments, 1), 
              fToBind = this, 
              fNOP = function () {},
              fBound = function () {
                return fToBind.apply(this instanceof fNOP && oThis
                       ? this
                       : oThis,
                       aArgs.concat(Array.prototype.slice.call(arguments)));
              };

          fNOP.prototype = this.prototype;
          fBound.prototype = new fNOP();

          return fBound;
        };
      }

      // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
      // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
      // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
      // MIT license
      (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
          window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
          window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
        }
        if (!window.requestAnimationFrame)
          window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
          };
       
        if (!window.cancelAnimationFrame)
          window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
          };
      }());

      
      // POLYFILL FOR addEventListener/removeEventListener function --> for IE8
      // found on https://gist.github.com/jonathantneal/3748027
      try {
        !window.addEventListener && (function (WindowPrototype, DocumentPrototype, ElementPrototype, addEventListener, removeEventListener, dispatchEvent, registry) {
          WindowPrototype[addEventListener] = DocumentPrototype[addEventListener] = ElementPrototype[addEventListener] = function (type, listener) {
            var target = this;

            registry.unshift([target, type, listener, function (event) {
              event.currentTarget = target;
              event.preventDefault = function () { event.returnValue = false };
              event.stopPropagation = function () { event.cancelBubble = true };
              event.target = event.srcElement || target;

              listener.call(target, event);
            }]);

            this.attachEvent("on" + type, registry[0][3]);
          };

          WindowPrototype[removeEventListener] = DocumentPrototype[removeEventListener] = ElementPrototype[removeEventListener] = function (type, listener) {
            for (var index = 0, register; register = registry[index]; ++index) {
              if (register[0] == this && register[1] == type && register[2] == listener) {
                return this.detachEvent("on" + type, registry.splice(index, 1)[0][3]);
              }
            }
          };

          WindowPrototype[dispatchEvent] = DocumentPrototype[dispatchEvent] = ElementPrototype[dispatchEvent] = function (eventObject) {
            return this.fireEvent("on" + eventObject.type, eventObject);
          };
        })(Window.prototype, HTMLDocument.prototype, Element.prototype, "addEventListener", "removeEventListener", "dispatchEvent", []);
      }
      catch (e) {
        browserNotification();
        return false;
      }
      
    }
    
    
    function GalleryClicked(e) {
    
      var r=GalleryEventRetrieveElementl(e, false);

      if( r.GOMidx == -1 ) {
        return;
      }
      
      var idx=G.GOM.items[r.GOMidx].thumbnailIdx;
      switch( r.action ) {
        case 'OPEN':
          ThumbnailOpen(idx);
          break;
        case 'TOGGLESELECT':
          ThumbnailSelectionToggle(idx);
          break;
      }
    }
    
    function ThumbnailSelectionClear() {
      G.GOM.nbSelected=0;
      var nbTn=G.GOM.items.length;
      for( var i=0; i < nbTn ; i++ ) {
        var item=G.I[G.GOM.items[i].thumbnailIdx];
        if( item.selected ) {
          item.selected=false;
          if(typeof G.O.fnThumbnailSelection === 'function'){
            // called when the selection status of an item changed
            G.O.fnThumbnailSelection(item.$elt, item, G.I);
          }
        }
        item.selected=false;
      }
    }
    
    function ThumbnailSelectionToggle(idx){
      var item=G.I[idx];
      if( item.selected === true ) {
        ThumbnailSelectionSet(item, false);
        G.GOM.nbSelected--;
      }
      else {
        ThumbnailSelectionSet(item, true);
        G.GOM.nbSelected++;
      }
    }
    
    
    // this replaces ThumbnailSelection()
    function ThumbnailSelectionSet(item, selected ){
      
      item.selected=selected;
      
      ThumbnailSelectionSetIcon( item );
      
      if(typeof G.O.fnThumbnailSelection === 'function'){
        // called when the selection status of an item changed
        G.O.fnThumbnailSelection(item.$elt, item, G.I);
      }
    
    }
    
    function ThumbnailSelectionSetIcon( item ) {
      if( item.$elt == null ) {
        // thumbnail is not built
        return;
      }
      var $sub=item.$getElt('.nGY2GThumbnailSub');
      var $icon=item.$getElt('.nGY2GThumbnailIconImageSelect');
      if( item.selected === true) {
        $sub.addClass('nGY2GThumbnailSubSelected');
        $icon.addClass('nGY2ThumbnailSelected');
        $icon.removeClass('nGY2ThumbnailUnselected');
      }
      else {
        $sub.removeClass('nGY2GThumbnailSubSelected');
        $icon.removeClass('nGY2ThumbnailSelected');
        $icon.addClass('nGY2ThumbnailUnselected');
      }
    }
    
    

    function GalleryMouseEnter(e) {
      if( !G.containerViewerDisplayed ) {
        var r=GalleryEventRetrieveElementl(e, true);
        // if( r.action == 'OPEN' && r.GOMidx != -1 ) {
        if( r.GOMidx != -1 ) {
          ThumbnailHover(r.GOMidx);
        }
      }
    }
    
    function GalleryMouseLeave(e) {
      if( !G.containerViewerDisplayed ) {
        var r=GalleryEventRetrieveElementl(e, true);
        // if( r.action == 'OPEN' && r.GOMidx != -1 ) {
        if( r.GOMidx != -1 ) {
          ThumbnailHoverOut(r.GOMidx);
        }
      }
    }
    
    function GalleryEventRetrieveElementl( e, ignoreSubItems ) {
      var r= { action:'NONE', GOMidx:-1 };
      
      if( e == undefined ) {
        return r;
      }
      var target = e.target || e.srcElement;
      while( target != G.$E.conTnParent[0] ) {       // loop element parent up to find the thumbnail element
        if( jQuery(target).hasClass('nGY2GThumbnail') ) {
          if( r.action == 'NONE' ) {
            r.action='OPEN';
          }
          r.GOMidx=jQuery(target).data('index');
          return r;
        }
        if( !ignoreSubItems && jQuery(target).hasClass('nGY2GThumbnailIcon') ) {
          var a=jQuery(target).data('action');
          if( a != '' ) {
            r.action=a;
          }
        }
        if( target.parentNode == null ) {
          return r;
        }
        target = target.parentNode;
      }
      return r;
    }
    
    
    function ThumbnailOpen( idx ) {
      var item=G.I[idx];

      if( typeof G.O.fnThumbnailClicked === 'function' ){
        if( !G.O.fnThumbnailClicked(item.$elt, item) ) { return; }
      }
      
      // open URL
      if( item.destinationURL !== undefined && item.destinationURL.length > 0 ) {
        window.location = item.destinationURL;
        return;
      }

      switch( item.kind ) {
        case 'image':
          if( G.GOM.nbSelected > 0 ) {
            ThumbnailSelectionToggle(idx);
          }
          else {
            // display image
          }
          break;
        case 'album':
          if( G.GOM.nbSelected > 0 ) {
            ThumbnailSelectionToggle(idx);
          }
          else {
            displayAlbum('-1', item.GetID());
          }
          break;
        case 'albumUp':
          var parent=NGY2Item.Get(G, item.albumID);
          displayAlbum('-1', parent.albumID);
          break;
      }
      
      
    }
    

    /** @function buildSkeleton */
    /** Build the gallery structure **/
    function buildSkeleton() {
    
      // RTL or LTR
      var sRTL='';
      if( G.O.RTL ) {
        sRTL='style="text-align:right;direction:rtl;"';
      }
    
      // theme
      G.$E.base.addClass(G.O.theme)
      // gallery color scheme
      SetColorScheme();


      // Hide icons (thumbnails and breadcrumb)
      if( G.O.thumbnailLabel.get('hideIcons') ) {
        var s1 = '.nanogallery_thumbnails_icons_off ',
        s = s1+'.nanoGalleryContainer .nanoGalleryThumbnailContainer .labelImageTitle:before { display:none; }'+'\n';
        s += s1+'.nanoGalleryContainer .nanoGalleryThumbnailContainer .labelFolderTitle:before { display:nonet; }'+'\n';
        jQuery('head').append('<style>'+s+'</style>');
        G.$E.base.addClass('nanogallery_thumbnails_icons_off');
      }
      if( G.O.galleryToolbarHideIcons ) {
        var s1 = '.nanogallery_breadcrumb_icons_off ',
        s=s1+'.nGY2tDNavigationbar .folderHome:before { display:none; }'+'\n';
        s += s1+'.nGY2tDNavigationbar .folder:before { display:none; }'+'\n';
        jQuery('head').append('<style>'+s+'</style>');
        G.$E.base.addClass('nanogallery_breadcrumb_icons_off');
      }

      if( G.O.thumbnailLabel.get('align') == 'right' ) {
        var s1 = '.nanogallery_thumbnails_label_align_right ',
        s = s1+'.nGY2GThumbnailLabel { text-align : right; }'+'\n';
        jQuery('head').append('<style>'+s+'</style>');
        G.$E.base.addClass('nanogallery_thumbnails_label_align_right');
      }

      if( G.O.thumbnailLabel.get('align') == 'center' ) {
        var s1 = '.nanogallery_thumbnails_label_align_center ',
        s = s1+'.nGY2GThumbnailLabel { text-align : center; }'+'\n';
        jQuery('head').append('<style>'+s+'</style>');
        G.$E.base.addClass('nanogallery_thumbnails_label_align_center');
      }
        
      if( G.O.thumbnailLabel.get('align') == 'left' ) {
        var s1 = '.nanogallery_thumbnails_label_align_left ',
        s = s1+'.nGY2GThumbnailLabel { text-align : left; }'+'\n';
        jQuery('head').append('<style>'+s+'</style>');
        G.$E.base.addClass('nanogallery_thumbnails_label_align_left');
      }

      
      // Navigation bar
      G.$E.conNavBCon=jQuery('<div class="nGY2tDNavigationbarContainer"></div>').appendTo(G.$E.base);
//      G.$E.conNavBCon.hide();//css('visibility','hidden');
      G.$E.conNavB=jQuery('<div class="nGY2tDNavigationbar"></div>').appendTo(G.$E.conNavBCon);
      G.$E.conBC=jQuery('<div class="nGY2tDBreadcrumb" '+sRTL+'></div>').appendTo(G.$E.conNavB);

      // pre-loader
      G.$E.conLoadingB=jQuery('<div class="nanoGalleryLBarOff"><div></div><div></div><div></div><div></div><div></div></div>').appendTo(G.$E.base);

      // gallery
      G.$E.conTnParent=jQuery('<div class="nGY2Gallery"></div>').appendTo(G.$E.base);
      G.$E.conTn=jQuery('<div class="nGY2GallerySub"></div>').appendTo(G.$E.conTnParent);
//      G.$E.conTnParent[0].addEventListener('click', GalleryClicked, true);
      G.$E.conTnParent.on({
        mouseenter: GalleryMouseEnter,
        mouseleave: GalleryMouseLeave
      }, ".nGY2GThumbnail"); //pass the element as an argument to .on
      
      // Gallery bottom container
      G.$E.conTnBottom=jQuery('<div class="nGY2GalleryBottom"></div>').appendTo(G.$E.conTnParent);
      
      // Error console
      G.$E.conConsole=jQuery('<div class="nGY2ConsoleParent"></div>').appendTo(G.$E.base);

      // i18n translations
      i18n();

      // cache some thumbnails data (sizes, styles...)
      ThumbnailDefCaches();

      // pagination
      G.pgMaxNbThumbnailsPerRow=NbThumbnailsPerRow();
    }
    
    /** @function setGlobalEvents */
    function setGlobalEvents() {
      // GLOBAL EVENT MANAGEMENT
      
      // gallery event management
      var t= new GalleryUserEvents();

      
      // Page resize
      jQuery(window).on('resize', debounce( ResizeWindowEvent, 100, false) );
      
      // Event page scrolled
      $(window).on('scroll',  debounce( OnScrollEvent, 100, false) );
      // $(window).scroll(function() { OnScrollEvent(); });
      //G.$E.base.on('scroll', function () {
      //  OnScroll();
      //});

    }
    
    function ResizeWindowEvent() {
      if( G.containerViewerDisplayed ) {
        ResizeInternalViewer();
      }
      else {
        if( G.galleryResizeEventEnabled ) {
          var nw=RetrieveCurWidth();
          // if( G.curAlbumIdx != -1 && G.curWidth != nw ) {
          if( G.GOM.albumIdx != -1 && 
                ( G.tn.settings.getH() != G.tn.settings.height[G.curNavLevel][nw] || 
                G.tn.settings.getW() != G.tn.settings.width[G.curNavLevel][nw] ) ) {
            // thumbnail size changed --> render the gallery with the new sizes
            G.curWidth=nw;
            G.layout.SetEngine();
            G.paginationCurrentPage=0;
            GalleryRender( G.GOM.albumIdx );
          }
          else {
            //ResizeGallery();
            GalleryResize();
          }
        }
      }
    }
    
    
    // DEBOUNCE
    // author: John Hann - http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
    // execAsap - false means executing at the end of the detection period
    var debounce = function (func, threshold, execAsap) {
console.log('debounce');
      var timeout;
      return function debounced () {
          var obj = this, args = arguments;
          function delayed () {
              if (!execAsap)
                  func.apply(obj, args);
              timeout = null; 
          };
   
          if (timeout)
              clearTimeout(timeout);
          else if (execAsap)
              func.apply(obj, args);
   
          timeout = setTimeout(delayed, threshold || 100); 
      };
    }

    

  
    
    function OnScrollEvent() {
      if( G.scrollTimeOut ) {
        clearTimeout(G.scrollTimeOut);
      }
      G.scrollTimeOut = setTimeout(function () {
      
console.log('OnScrollEvent');
      
        if( !G.containerViewerDisplayed ) {
          //thumbnailsLazySetSrc();
          if( G.galleryResizeEventEnabled ) {
            GalleryResize();
          }
          return;
        }
      }, 10);
    }

    
    // ##### GALLERY USER EVENTS HANDLING (click, hover, swipe, drag)
    // based on article "Implement Custom Gestures" from Google
    // https://developers.google.com/web/fundamentals/input/touch-input/touchevents/
    function GalleryUserEvents() {
console.log('GalleryUserEvents');
      var elementToSwipe=G.$E.conTn[0],
      isAnimating=false,
      initialTouchPos=null,
      lastTouchPos=null,
      currentXPosition=0,
      onlyX=false,
      startViewport=null;
      
      var initialViewport=0;
      

      // Handle the start of gestures -->  click event
      this.handleGestureStartNoDelay = function(e) {
console.log('handleGestureStartNoDelay');      

        var r=GalleryEventRetrieveElementl(e, false);

        if( r.action == 'TOGGLESELECT' ) {
          // ThumbnailSelectionToggle(G.GOM.items[r.GOMidx].thumbnailIdx);
          // e.stopPropagation();
          // return false;
        }
        
        // if items are selectable, cannot limit on user speed
        if( (new Date().getTime()) - G.timeLastTouchStart < 400 && G.O.itemsSelectable !== true ) {
//          return; 
        }
        G.openNoDelay=true;
        this.handleGestureStart(e);
      }.bind(this);


      // Handle the start of gestures
      this.handleGestureStart = function(e) {
console.log('handleGestureStart');      

  


//        var eType=(jQuery(e.target).get(0).tagName).toUpperCase();
        // class customEventHandler --> disable standard event handler
//        if( G.containerViewerDisplayed || eType == 'A' || eType == 'INPUT' || jQuery(e.target).hasClass('customEventHandler') ) {     // detect click on custom element
//          e.stopPropagation();
          //e.eventDefault();
//          return false;
//        }

        if( (new Date().getTime()) - G.timeImgChanged < 400 && G.O.itemsSelectable !== true ) { 
//          return;
        }     
        
        if( (new Date().getTime()) - G.timeLastTouchStart < 400 && G.O.itemsSelectable !== true ) {
//          return;
        }
        G.timeLastTouchStart=new Date().getTime();
console.log('handleGestureStart2');
        
        var target = e.target || e.srcElement;
        var found=false;
        while( target != G.$E.conTn[0] ) {       // go element parent up to find the thumbnail element
          // if( target.getAttribute('class') == 'nanoGalleryThumbnailContainer' ) {
          if( jQuery(target).hasClass('nGY2GThumbnail') ) {
            if( G.$currentTouchedThumbnail != null && !G.$currentTouchedThumbnail.is(jQuery(target)) ) {
              ThumbnailHoverOutAll();
            }
            G.$currentTouchedThumbnail=jQuery(target);
            found=true;
          }
          target = target.parentNode;
        }
console.log('handleGestureStart2a');
        
        if( !found ) { return; }

console.log('handleGestureStart3');
        // handle thumbnail selection
if( true == false ) {
        if(G.O.itemsSelectable === true){
          if(G.isShiftPressed || G.isCtrlPressed || G.isMetaPressed || e.target.nodeName.toLowerCase() === 'input'){
            thumbnailSelection( G.I[G.$currentTouchedThumbnail.data('index')] );
            return false;
          }
          if (G.selectMode === true) {
            thumbnailSelection( G.I[G.$currentTouchedThumbnail.data('index')] );
            return false;
          }
          if (G.I[G.$currentTouchedThumbnail.data('index')].kind === G.selectMode) {
            thumbnailSelection( G.I[G.$currentTouchedThumbnail.data('index')] );
            return false;
          }
          var idxctt = G.$currentTouchedThumbnail.data('index');
          G.touchSelectTO = setTimeout(function(){
            thumbnailSelection( G.I[idxctt] );
          },500);
        }
}

console.log('handleGestureStart4');
      
        initialViewport=getViewport();
        
        //if(e.touches && e.touches.length > 1) { return; }
        initialTouchPos = getGesturePointFromEvent(e);

        //if( G.gallerySwipeInitDone ) { return; }
        
        // Add the move and end listeners
        if (window.navigator.msPointerEnabled) {
          // Pointer events are supported.
          document.addEventListener('MSPointerMove', this.handleGestureMove, true);
          document.addEventListener('MSPointerUp', this.handleGestureEnd, true);
        } else {
          // Add Touch Listeners
          document.addEventListener('touchmove', this.handleGestureMove, true);
          document.addEventListener('touchend', this.handleGestureEnd, true);
          document.addEventListener('touchcancel', this.handleGestureEnd, true);
        
          // Add Mouse Listeners
          document.addEventListener('mousemove', this.handleGestureMove, true);
          document.addEventListener('mouseup', this.handleGestureEnd, true);
        }
        
        // makes content unselectable --> avoid image drag during 'mouse swipe'
        G.$E.base.addClass('unselectable').find('*').attr('draggable', 'false').attr('unselectable', 'on');
        G.gallerySwipeInitDone=true;
        
      }.bind(this);
      
      // Handle move gestures
      this.handleGestureMove = function (e) {
//console.log('handleGestureMove');      
        //e.preventDefault(); // --> uncomment this to avoid viewport scrolling on touchscreen
        lastTouchPos = getGesturePointFromEvent(e);
        
        if( isAnimating ) { return; }

        if( G.O.paginationSwipe ) {
//console.log('handleGestureMove2');      
          if( G.layout.support.pagination && G.pgMaxLinesPerPage > 0 ) {
            if( Math.abs(initialTouchPos.x - lastTouchPos.x) > 15 || onlyX ) {
              e.preventDefault(); // if swipe horizontaly the gallery, avoid moving page also
              onlyX=true;
              isAnimating = true;
              window.requestAnimationFrame(onAnimFrame);
            }
          }
        }

      }.bind(this);

      
      // Handle end gestures
      this.handleGestureEnd = function(e) {
        if( e.cancelable ) { e.preventDefault(); }
        e.stopPropagation();
        
        // if(e.touches && e.touches.length > 0) {
        //   return;
        // }
        isAnimating = false;
        onlyX=false;
        
        // Remove Event Listeners
        if (window.navigator.msPointerEnabled) {
          // Remove Pointer Event Listeners
          document.removeEventListener('MSPointerMove', this.handleGestureMove, true);
          document.removeEventListener('MSPointerUp', this.handleGestureEnd, true);
        } else {
          // Remove Touch Listeners
          document.removeEventListener('touchmove', this.handleGestureMove, true);
          document.removeEventListener('touchend', this.handleGestureEnd, true);
          document.removeEventListener('touchcancel', this.handleGestureEnd, true);
        
          // Remove Mouse Listeners
          document.removeEventListener('mousemove', this.handleGestureMove, true);
          document.removeEventListener('mouseup', this.handleGestureEnd, true);
        }

if( true == false ) {
        if(G.O.itemsSelectable === true){
          if((new Date().getTime() - G.timeLastTouchStart) > 500 ){
            return false;
          }else{
            clearTimeout(G.touchSelectTO);
          }
        }
}

        // allow text + image selection again
        G.$E.base.addClass('unselectable').find('*').attr('draggable', 'true').attr('unselectable', 'off');

        GestureEndAction(e);
        
        initialTouchPos=null;
        lastTouchPos=null;
        currentXPosition=0;
        onlyX=false;
        startViewport=null;

      }.bind(this);
      
      function OpenTouchedThumbnail(e) {
        currentXPosition=0;
        initialTouchPos=null;
        lastTouchPos=null;
        ElementTranslateX(G.$E.conTn[0],0);
        
        //GalleryClicked(e);

        if( Math.abs(initialViewport.t-getViewport().t) > 10 ) {
          // viewport has been scrolled vertically (touchscreen)--> action is cancelled
//          ThumbnailHoverOut(G.$currentTouchedThumbnail);
          G.$currentTouchedThumbnail=null;
          G.openNoDelay=false;
          return;
        }

        
        
        var r=GalleryEventRetrieveElementl(e, false);

        if( r.GOMidx == -1 ) {
          return;
        }
        
        var idx=G.GOM.items[r.GOMidx].thumbnailIdx;
        if( r.action == 'TOGGLESELECT' ) {
          ThumbnailSelectionToggle(idx);
          return;
        }

        
        // if( ( G.curNavLevel == 'l1' && G.O.touchAnimationL1 !== undefined ? G.O.touchAnimationL1: G.O.touchAnimation) && !G.openNoDelay ) {
        if( ( true ) {
          // automatically opens the touched thumbnail (to display an image or to open an album)
          if( G.O.touchAutoOpenDelay > 0 ) { 
            ThumbnailHoverOutAll();
            ThumbnailHover(r.GOMidx);
            window.clearInterval(G.touchAutoOpenDelayTimerID);
            G.touchAutoOpenDelayTimerID=window.setInterval(function(){
              window.clearInterval(G.touchAutoOpenDelayTimerID);
              if( Math.abs(initialViewport.t-getViewport().t) > 10 ) {
                // viewport has been scrolled after hover effect delay (touchscreen)--> open is cancelled
                G.openNoDelay=false;
                G.$currentTouchedThumbnail=null;
                ThumbnailHoverOut(r.GOMidx);
              }
              else {
                ThumbnailOpen(idx);
              }
            }, G.O.touchAutoOpenDelay);
          }
          else {
            // 2 touch scenario
            if( !G.I[idx].hovered ) {
              // first touch
              ThumbnailHoverOutAll();
              ThumbnailHover(r.GOMidx);
            }
            else {
              // second touch
              ThumbnailOpen(idx);
            }
          }
        }
        else {
          ThumbnailOpen(idx);
//OpenThumbnail(n);
        }
        
        
        
        
        
        
        
        
        
        
        
        return;
        
        
        if( G.containerViewerDisplayed || G.$currentTouchedThumbnail == null ) {
          G.$currentTouchedThumbnail=null;
          G.openNoDelay=false;
          return;
        }

        if( Math.abs(initialViewport.t-getViewport().t) > 10 ) {
          // viewport has been scrolled (touchscreen)--> open is cancelled
          ThumbnailHoverOut(G.$currentTouchedThumbnail);
          G.$currentTouchedThumbnail=null;
          G.openNoDelay=false;
          return;
        }
        
        var $t=G.$currentTouchedThumbnail;
        var n=$t.data('index');
        if( n == undefined ) {
          G.$currentTouchedThumbnail=null;
          G.openNoDelay=false;
          return;
        }
        
        if( ( G.curNavLevel == 'l1' && G.O.touchAnimationL1 !== undefined ? G.O.touchAnimationL1: G.O.touchAnimation) && !G.openNoDelay ) {
          // automatically opens the touched thumbnail (to display an image or to open an album)
          if( G.O.touchAutoOpenDelay > 0 ) { 
            ThumbnailHoverOutAll();
            ThumbnailHover($t);
            window.clearInterval(G.touchAutoOpenDelayTimerID);
            G.touchAutoOpenDelayTimerID=window.setInterval(function(){
              window.clearInterval(G.touchAutoOpenDelayTimerID);
              if( Math.abs(initialViewport.t-getViewport().t) > 10 ) {
                // viewport has been scrolled after hover effect delay (touchscreen)--> open is cancelled
                G.openNoDelay=false;
                G.$currentTouchedThumbnail=null;
                ThumbnailHoverOut($t);
              }
              else {
                OpenThumbnail(n);
              }
            }, G.O.touchAutoOpenDelay);
          }
          else {
            // 2 touch scenario
            if( !G.I[n].hovered ) {
              // first touch
              ThumbnailHoverOutAll();
              ThumbnailHover($t);
            }
            else {
              // second touch
              OpenThumbnail(n);
            }
          }
        }
        else {
          OpenThumbnail(n);
        }


        return;
      }
      
      function GestureEndAction(e) {
console.log('GestureEndAction');

        if( lastTouchPos == null || initialTouchPos == null ) {      // touchend without touchmove
          OpenTouchedThumbnail(e);
          return;
        }

        var differenceInX = initialTouchPos.x - lastTouchPos.x;
        var differenceInY = initialTouchPos.y - lastTouchPos.y;
        currentXPosition = currentXPosition - differenceInX;
        if( G.O.paginationSwipe && G.layout.support.pagination && G.pgMaxLinesPerPage > 0 ) {
          // pagination
          if(  (Math.abs(differenceInX) > 40 && Math.abs(initialViewport.t-getViewport().t) <= 10) ) {
            G.$currentTouchedThumbnail=null;
            currentXPosition=0;
            initialTouchPos=null;
            lastTouchPos=null;
            ThumbnailHoverOutAll();
            if( differenceInX < -40 ) {
              paginationPreviousPage();
              return;
            }
            else {
              paginationNextPage();
              return;
            }
          }
        }
        
        // no pagination
        OpenTouchedThumbnail(e);

        return;
      }

      function getGesturePointFromEvent(e) {
        var point = {};

        if(e.targetTouches) {
          point.x = e.targetTouches[0].clientX;
          point.y = e.targetTouches[0].clientY;
        } else {
          // Either Mouse event or Pointer Event
          point.x = e.clientX;
          point.y = e.clientY;
        }

        return point;
      }
      
      function onAnimFrame() {
        if(!isAnimating) { return; }
        
        if( G.layout.support.pagination && G.pgMaxLinesPerPage > 0 ) {
          var differenceInX = initialTouchPos.x - lastTouchPos.x;
          ElementTranslateX(elementToSwipe,currentXPosition - differenceInX);
        }

        isAnimating = false;
      }

      
      // Check if MS pointer events are supported.
      if (window.navigator.msPointerEnabled) {
        // Add Pointer Event Listener
        elementToSwipe.addEventListener('MSPointerDown', this.handleGestureStartNoDelay, true);
      }
      else {
        // Add Touch Listener
        elementToSwipe.addEventListener('touchstart', this.handleGestureStart, true);
        
        // Add Mouse Listener
        if( !G.isIOS ) {
          var thatObject = this;
          elementToSwipe.addEventListener('mousedown', function(e){
              // filter : if the user uses the right click, 
              // do not do anything
//              if(e.button != 2){
                thatObject.handleGestureStartNoDelay(e);
//            }
          }, true);
        }
      }
      
      // MOUSE OVER
//      elementToSwipe.addEventListener('mouseenter', ThumbnailOnMouseenter, true);
//      elementToSwipe.addEventListener('mouseleave', ThumbnailOnMouseleave, true);
      // $(elementToSwipe).on({
        // mouseenter: GalleryMouseEnter,
        // mouseleave: GalleryMouseLeave
      // }, ".nGY2GThumbnail"); //pass the element as an argument to .on
      
    }    
    
    
    // I18N : define text translations
    function i18n() {

      // browser language
      G.i18nLang = (navigator.language || navigator.userLanguage).toUpperCase();
      if( G.i18nLang === 'UNDEFINED') { G.i18nLang=''; }

      var llang=-('_'+G.i18nLang).length;
      
      if( toType(G.O.i18n) == 'object' ){
      
        for( var key in G.O.i18n ) {
          //var value = G.O.i18n[key];
          var s=key.substr(llang);
          if( s == ('_'+G.i18nLang) ) {
            G.i18nTranslations[key.substr(0,key.length-s.length)]=G.O.i18n[key];
          } 
          else {
            G.i18nTranslations[key]=G.O.i18n[key];
          }
        }
      }
    }

    
    function RetrieveCurWidth() {
      var vpW= getViewport().w;
      
      if( G.O.breakpointSizeSM > 0 && vpW < G.O.breakpointSizeSM) { return 'xs'; }
      if( G.O.breakpointSizeME > 0 && vpW < G.O.breakpointSizeME) { return 'sm'; }
      if( G.O.breakpointSizeLA > 0 && vpW < G.O.breakpointSizeLA) { return 'me'; }
      if( G.O.breakpointSizeXL > 0 && vpW < G.O.breakpointSizeXL) { return 'la'; }
      
      return 'xl';
    }

    
    /** @function browserNotification */
    function browserNotification() {
      var m='Your browser version is not supported anymore. The image gallery cannot be displayed. <br><br>Please update to a more recent one. Download:<br>';
      m+='&nbsp;&nbsp;&nbsp; <a href="http://www.google.com/chrome/?hl=en-US)">Chrome</a><br>';
      m+='&nbsp;&nbsp;&nbsp; <a href="http://www.mozilla.com/firefox/)">Firefox</a><br>';
      m+='&nbsp;&nbsp;&nbsp; <a href="http://www.microsoft.com/windows/internet-explorer/default.aspx">Internet Explorer</a><br>';
      m+='&nbsp;&nbsp;&nbsp; <a href="http://www.apple.com/safari/download/">Safari</a>';
      NGY2Tools.nanoAlert(G, m, false);
    }

    // Original author : John Hrvatin, Lead Program Manager, Internet Explorer - http://blogs.msdn.com/b/ie/archive/2011/10/28/a-best-practice-for-programming-with-vendor-prefixes.aspx
    function FirstSupportedPropertyName(prefixedPropertyNames) {
      var tempDiv = document.createElement("div");
      for (var i = 0; i < prefixedPropertyNames.length; ++i) {
        if (typeof tempDiv.style[prefixedPropertyNames[i]] != 'undefined')
          return prefixedPropertyNames[i];
      }
      return null;
    }

    // #################
    // ##### TOOLS #####
    // #################

    // get viewport coordinates and size
    function getViewport() {
      var $win = jQuery(window);
      return {
        l: $win.scrollLeft(),
        t: $win.scrollTop(),
        w: $win.width(),
        h: $win.height()
      }
    }


    // avoid if possible (performance issue)
    function inViewport( $elt, threshold ) {
      var wp=getViewport(),
      eltOS=$elt.offset(),
      th=$elt.outerHeight(true),
      tw=$elt.outerWidth(true);
      if( eltOS.top >= (wp.t-threshold) 
        && (eltOS.top+th) <= (wp.t+wp.h+threshold)
        && eltOS.left >= (wp.l-threshold) 
        && (eltOS.left+tw) <= (wp.l+wp.w+threshold) ) {
        return true;
      }
      else {
        return false;
      }
    }

    // avoid if possible (performance issue)
    function inViewportVert( $elt, threshold ) {
      var wp=getViewport(),
      eltOS=$elt.offset(),
      th=$elt.outerHeight(true),
      tw=$elt.outerWidth(true);

      if( wp.t == 0 && (eltOS.top) <= (wp.t+wp.h ) ) { return true; }

      if( eltOS.top >= (wp.t) 
        && (eltOS.top+th) <= (wp.t+wp.h-threshold) ) {
          return true;
      }
      else {
        return false;
      }
    }

    
    // return the real type of the object
    var toType = function( obj ) {
      // by Angus Croll - http://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/
      return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()
    };
    

    
  }
  
  
  
// END NANOGALLERY2
}( jQuery ));
  
  
  
//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################

// TinyColor v1.1.2
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function() {

var trimLeft = /^[\s,#]+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    math = Math,
    mathRound = math.round,
    mathMin = math.min,
    mathMax = math.max,
    mathRandom = math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function() {
        return rgbaToHex(this._r, this._g, this._b, this._a);
    },
    toHex8String: function() {
        return '#' + this.toHex8();
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = s.toHex8String();
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
            color.s = convertToPercentage(color.s);
            color.v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, color.s, color.v);
            ok = true;
            format = "hsv";
        }
        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
            color.s = convertToPercentage(color.s);
            color.l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, color.s, color.l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}
    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b and a are contained in the set [0, 255]
    // Returns an 8 character hex
    function rgbaToHex(r, g, b, a) {

        var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        return hex.join("");
    }

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (mathRound(hsl.h) + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;
    var w = p * 2 - 1;
    var a = rgb2.a - rgb1.a;

    var w1;

    if (w * a == -1) {
        w1 = w;
    } else {
        w1 = (w + a) / (1 + w * a);
    }

    w1 = (w1 + 1) / 2;

    var w2 = 1 - w1;

    var rgba = {
        r: rgb2.r * w1 + rgb1.r * w2,
        g: rgb2.g * w1 + rgb1.g * w2,
        b: rgb2.b * w1 + rgb1.b * w2,
        a: rgb2.a * p  + rgb1.a * (1 - p)
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/AERT#color-contrast>

// `readability`
// Analyze the 2 colors and returns an object with the following properties:
//    `brightness`: difference in brightness between the two colors
//    `color`: difference in color/hue between the two colors
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    var rgb1 = c1.toRgb();
    var rgb2 = c2.toRgb();
    var brightnessA = c1.getBrightness();
    var brightnessB = c2.getBrightness();
    var colorDiff = (
        Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) +
        Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) +
        Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b)
    );

    return {
        brightness: Math.abs(brightnessA - brightnessB),
        color: colorDiff
    };
};

// `readable`
// http://www.w3.org/TR/AERT#color-contrast
// Ensure that foreground and background color combinations provide sufficient contrast.
// *Example*
//    tinycolor.isReadable("#000", "#111") => false
tinycolor.isReadable = function(color1, color2) {
    var readability = tinycolor.readability(color1, color2);
    return readability.brightness > 125 && readability.color > 500;
};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// *Example*
//    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
tinycolor.mostReadable = function(baseColor, colorList) {
    var bestColor = null;
    var bestScore = 0;
    var bestIsReadable = false;
    for (var i=0; i < colorList.length; i++) {

        // We normalize both around the "acceptable" breaking point,
        // but rank brightness constrast higher than hue.

        var readability = tinycolor.readability(baseColor, colorList[i]);
        var readable = readability.brightness > 125 && readability.color > 500;
        var score = 3 * (readability.brightness / 125) + (readability.color / 500);

        if ((readable && ! bestIsReadable) ||
            (readable && bestIsReadable && score > bestScore) ||
            ((! readable) && (! bestIsReadable) && score > bestScore)) {
            bestIsReadable = readable;
            bestScore = score;
            bestColor = tinycolor(colorList[i]);
        }
    }
    return bestColor;
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            a: convertHexToDecimal(match[1]),
            r: parseIntFromHex(match[2]),
            g: parseIntFromHex(match[3]),
            b: parseIntFromHex(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})();

//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################

/*!
 * imagesLoaded PACKAGED v3.1.8
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */


/*!
 * EventEmitter v4.2.6 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function () {
	

	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class ngEventEmitter Manages event registering and emitting.
	 */
	function ngEventEmitter() {}

	// Shortcuts to improve speed and size
	var proto = ngEventEmitter.prototype;
	var exports = this;
	var originalGlobalValue = exports.ngEventEmitter;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @param {Function} listener Method to look for.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listeners, listener) {
		var i = listeners.length;
		while (i--) {
			if (listeners[i].listener === listener) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Alias a method while keeping the context correct, to allow for overwriting of target method.
	 *
	 * @param {String} name The name of the target method.
	 * @return {Function} The aliased method
	 * @api private
	 */
	function alias(name) {
		return function aliasClosure() {
			return this[name].apply(this, arguments);
		};
	}

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function getListeners(evt) {
		var events = this._getEvents();
		var response;
		var key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (typeof evt === 'object') {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Takes a list of listener objects and flattens it into a list of listener functions.
	 *
	 * @param {Object[]} listeners Raw listener objects.
	 * @return {Function[]} Just the listener functions.
	 */
	proto.flattenListeners = function flattenListeners(listeners) {
		var flatListeners = [];
		var i;

		for (i = 0; i < listeners.length; i += 1) {
			flatListeners.push(listeners[i].listener);
		}

		return flatListeners;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function getListenersAsObject(evt) {
		var listeners = this.getListeners(evt);
		var response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function addListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var listenerIsWrapped = typeof listener === 'object';
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
				listeners[key].push(listenerIsWrapped ? listener : {
					listener: listener,
					once: false
				});
			}
		}

		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = alias('addListener');

	/**
	 * Semi-alias of addListener. It will add a listener that will be
	 * automatically removed after it's first execution.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addOnceListener = function addOnceListener(evt, listener) {
		return this.addListener(evt, {
			listener: listener,
			once: true
		});
	};

	/**
	 * Alias of addOnceListener.
	 */
	proto.once = alias('addOnceListener');

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function defineEvent(evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function defineEvents(evts) {
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function removeListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var index;
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listeners[key], listener);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = alias('removeListener');

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function addListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function removeListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		var i;
		var value;
		var single = remove ? this.removeListener : this.addListener;
		var multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function removeEvent(evt) {
		var type = typeof evt;
		var events = this._getEvents();
		var key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (type === 'object') {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		return this;
	};

	/**
	 * Alias of removeEvent.
	 *
	 * Added to mirror the node API.
	 */
	proto.removeAllListeners = alias('removeEvent');

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function emitEvent(evt, args) {
		var listeners = this.getListenersAsObject(evt);
		var listener;
		var i;
		var key;
		var response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					listener = listeners[key][i];

					if (listener.once === true) {
						this.removeListener(evt, listener.listener);
					}

					response = listener.listener.apply(this, args || []);

					if (response === this._getOnceReturnValue()) {
						this.removeListener(evt, listener.listener);
					}
				}
			}
		}

		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = alias('emitEvent');

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function emit(evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	/**
	 * Sets the current value to check against when executing listeners. If a
	 * listeners return value matches the one set here then it will be removed
	 * after execution. This value defaults to true.
	 *
	 * @param {*} value The new value to check for when executing listeners.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.setOnceReturnValue = function setOnceReturnValue(value) {
		this._onceReturnValue = value;
		return this;
	};

	/**
	 * Fetches the current value to check against when executing listeners. If
	 * the listeners return value matches this one then it should be removed
	 * automatically. It will return true by default.
	 *
	 * @return {*|Boolean} The current value to check for or the default, true.
	 * @api private
	 */
	proto._getOnceReturnValue = function _getOnceReturnValue() {
		if (this.hasOwnProperty('_onceReturnValue')) {
			return this._onceReturnValue;
		}
		else {
			return true;
		}
	};

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function _getEvents() {
		return this._events || (this._events = {});
	};

	/**
	 * Reverts the global {@link ngEventEmitter} to its previous value and returns a reference to this version.
	 *
	 * @return {Function} Non conflicting ngEventEmitter class.
	 */
	ngEventEmitter.noConflict = function noConflict() {
		exports.ngEventEmitter = originalGlobalValue;
		return ngEventEmitter;
	};

	// Expose the class either via AMD, CommonJS or the global object
	if (typeof define === 'function' && define.amd) {
		define('ngEventEmitter/ngEventEmitter',[],function () {
			return ngEventEmitter;
		});
	}
	else if (typeof module === 'object' && module.exports){
		module.exports = ngEventEmitter;
	}
	else {
		this.ngEventEmitter = ngEventEmitter;
	}
}.call(this));

/*!
 * eventie v1.0.4
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false */

( function( window ) {



var docElem = document.documentElement;

var bind = function() {};

function getIEEvent( obj ) {
  var event = window.event;
  // add event.target
  event.target = event.target || event.srcElement || obj;
  return event;
}

if ( docElem.addEventListener ) {
  bind = function( obj, type, fn ) {
    obj.addEventListener( type, fn, false );
  };
} else if ( docElem.attachEvent ) {
  bind = function( obj, type, fn ) {
    obj[ type + fn ] = fn.handleEvent ?
      function() {
        var event = getIEEvent( obj );
        fn.handleEvent.call( fn, event );
      } :
      function() {
        var event = getIEEvent( obj );
        fn.call( obj, event );
      };
    obj.attachEvent( "on" + type, obj[ type + fn ] );
  };
}

var unbind = function() {};

if ( docElem.removeEventListener ) {
  unbind = function( obj, type, fn ) {
    obj.removeEventListener( type, fn, false );
  };
} else if ( docElem.detachEvent ) {
  unbind = function( obj, type, fn ) {
    obj.detachEvent( "on" + type, obj[ type + fn ] );
    try {
      delete obj[ type + fn ];
    } catch ( err ) {
      // can't delete window object properties
      obj[ type + fn ] = undefined;
    }
  };
}

var eventie = {
  bind: bind,
  unbind: unbind
};

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( 'eventie/eventie',eventie );
} else {
  // browser global
  window.eventie = eventie;
}

})( this );

/*!
 * imagesLoaded v3.1.8
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) { 
  // universal module definition

  /*global define: false, module: false, require: false */

  if ( typeof define === 'function' && define.amd ) {
    // AMD
    define( [
      'ngEventEmitter/ngEventEmitter',
      'eventie/eventie'
    ], function( ngEventEmitter, eventie ) {
      return factory( window, ngEventEmitter, eventie );
    });
  } else if ( typeof exports === 'object' ) {
    // CommonJS
    module.exports = factory(
      window,
      require('wolfy87-eventemitter'),
      require('eventie')
    );
  } else {
    // browser global
    window.ngimagesLoaded = factory(
      window,
      window.ngEventEmitter,
      window.eventie
    );
  }

})( window,

// --------------------------  factory -------------------------- //

function factory( window, ngEventEmitter, eventie ) {



var $ = window.jQuery;
var console = window.console;
var hasConsole = typeof console !== 'undefined';

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

var objToString = Object.prototype.toString;
function isArray( obj ) {
  return objToString.call( obj ) === '[object Array]';
}

// turn element or nodeList into an array
function makeArray( obj ) {
  var ary = [];
  if ( isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( typeof obj.length === 'number' ) {
    // convert nodeList to array
    for ( var i=0, len = obj.length; i < len; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
}

  // -------------------------- imagesLoaded -------------------------- //

  /**
   * @param {Array, Element, NodeList, String} elem
   * @param {Object or Function} options - if function, use as callback
   * @param {Function} onAlways - callback function
   */
  function ngImagesLoaded( elem, options, onAlways ) {
    // coerce ImagesLoaded() without new, to be new ImagesLoaded()
    if ( !( this instanceof ngImagesLoaded ) ) {
      return new ngImagesLoaded( elem, options );
    }
    // use elem as selector string
    if ( typeof elem === 'string' ) {
      elem = document.querySelectorAll( elem );
    }

    this.elements = makeArray( elem );
    this.options = extend( {}, this.options );

    if ( typeof options === 'function' ) {
      onAlways = options;
    } else {
      extend( this.options, options );
    }

    if ( onAlways ) {
      this.on( 'always', onAlways );
    }

    this.getImages();

    if ( $ ) {
      // add jQuery Deferred object
      this.jqDeferred = new $.Deferred();
    }

    // HACK check async to allow time to bind listeners
    var _this = this;
    setTimeout( function() {
      _this.check();
    });
  }

  ngImagesLoaded.prototype = new ngEventEmitter();

  ngImagesLoaded.prototype.options = {};

  ngImagesLoaded.prototype.getImages = function() {
    this.images = [];

    // filter & find items if we have an item selector
    for ( var i=0, len = this.elements.length; i < len; i++ ) {
      var elem = this.elements[i];
      // filter siblings
      if ( elem.nodeName === 'IMG' ) {
        this.addImage( elem );
      }
      // find children
      // no non-element nodes, #143
      var nodeType = elem.nodeType;
      if ( !nodeType || !( nodeType === 1 || nodeType === 9 || nodeType === 11 ) ) {
        continue;
      }
      var childElems = elem.querySelectorAll('img');
      // concat childElems to filterFound array
      for ( var j=0, jLen = childElems.length; j < jLen; j++ ) {
        var img = childElems[j];
        this.addImage( img );
      }
    }
  };

  /**
   * @param {Image} img
   */
  ngImagesLoaded.prototype.addImage = function( img ) {
    var loadingImage = new LoadingImage( img );
    this.images.push( loadingImage );
  };

  ngImagesLoaded.prototype.check = function() {
    var _this = this;
    var checkedCount = 0;
    var length = this.images.length;
    this.hasAnyBroken = false;
    // complete if no images
    if ( !length ) {
      this.complete();
      return;
    }

    function onConfirm( image, message ) {
      if ( _this.options.debug && hasConsole ) {
        console.log( 'confirm', image, message );
      }

      _this.progress( image );
      checkedCount++;
      if ( checkedCount === length ) {
        _this.complete();
      }
      return true; // bind once
    }

    for ( var i=0; i < length; i++ ) {
      var loadingImage = this.images[i];
      loadingImage.on( 'confirm', onConfirm );
      loadingImage.check();
    }
  };

  ngImagesLoaded.prototype.progress = function( image ) {
    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
    // HACK - Chrome triggers event before object properties have changed. #83
    var _this = this;
    setTimeout( function() {
      _this.emit( 'progress', _this, image );
      if ( _this.jqDeferred && _this.jqDeferred.notify ) {
        _this.jqDeferred.notify( _this, image );
      }
    });
  };

  ngImagesLoaded.prototype.complete = function() {
    var eventName = this.hasAnyBroken ? 'fail' : 'done';
    this.isComplete = true;
    var _this = this;
    // HACK - another setTimeout so that confirm happens after progress
    setTimeout( function() {
      _this.emit( eventName, _this );
      _this.emit( 'always', _this );
      if ( _this.jqDeferred ) {
        var jqMethod = _this.hasAnyBroken ? 'reject' : 'resolve';
        _this.jqDeferred[ jqMethod ]( _this );
      }
    });
  };

  // -------------------------- jquery -------------------------- //

  if ( $ ) {
    $.fn.ngimagesLoaded = function( options, callback ) {
      var instance = new ngImagesLoaded( this, options, callback );
      return instance.jqDeferred.promise( $(this) );
    };
  }


  // --------------------------  -------------------------- //

  function LoadingImage( img ) {
    this.img = img;
  }

  LoadingImage.prototype = new ngEventEmitter();

  LoadingImage.prototype.check = function() {
    // first check cached any previous images that have same src
    var resource = cache[ this.img.src ] || new Resource( this.img.src );
    if ( resource.isConfirmed ) {
      this.confirm( resource.isLoaded, 'cached was confirmed' );
      return;
    }

    // If complete is true and browser supports natural sizes,
    // try to check for image status manually.
    if ( this.img.complete && this.img.naturalWidth !== undefined ) {
      // report based on naturalWidth
      this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
      return;
    }

    // If none of the checks above matched, simulate loading on detached element.
    var _this = this;
    resource.on( 'confirm', function( resrc, message ) {
      _this.confirm( resrc.isLoaded, message );
      return true;
    });

    resource.check();
  };

  LoadingImage.prototype.confirm = function( isLoaded, message ) {
    this.isLoaded = isLoaded;
    this.emit( 'confirm', this, message );
  };

  // -------------------------- Resource -------------------------- //

  // Resource checks each src, only once
  // separate class from LoadingImage to prevent memory leaks. See #115

  var cache = {};

  function Resource( src ) {
    this.src = src;
    // add to cache
    cache[ src ] = this;
  }

  Resource.prototype = new ngEventEmitter();

  Resource.prototype.check = function() {
    // only trigger checking once
    if ( this.isChecked ) {
      return;
    }
    // simulate loading on detached element
    var proxyImage = new Image();
    eventie.bind( proxyImage, 'load', this );
    eventie.bind( proxyImage, 'error', this );
    proxyImage.src = this.src;
    // set flag
    this.isChecked = true;
  };

  // ----- events ----- //

  // trigger specified handler for event type
  Resource.prototype.handleEvent = function( event ) {
    var method = 'on' + event.type;
    if ( this[ method ] ) {
      this[ method ]( event );
    }
  };

  Resource.prototype.onload = function( event ) {
    this.confirm( true, 'onload' );
    this.unbindProxyEvents( event );
  };

  Resource.prototype.onerror = function( event ) {
    this.confirm( false, 'onerror' );
    this.unbindProxyEvents( event );
  };

  // ----- confirm ----- //

  Resource.prototype.confirm = function( isLoaded, message ) {
    this.isConfirmed = true;
    this.isLoaded = isLoaded;
    this.emit( 'confirm', this, message );
  };

  Resource.prototype.unbindProxyEvents = function( event ) {
    eventie.unbind( event.target, 'load', this );
    eventie.unbind( event.target, 'error', this );
  };

  // -----  ----- //

  return ngImagesLoaded;

});


//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################
//##########################################################################################################################
  
 /*!
 * Shifty
 * By Jeremy Kahn - jeremyckahn@gmail.com
 */

// NG BUILD:
// 
// replace "Tweenable" with "NGTweenable"
// replace "define.amd" with "define.amdDISABLED"
/*! shifty - v1.5.0 - 2015-05-31 - http://jeremyckahn.github.io/shifty */
(function(){var t=this,n=function(){"use strict";function n(){}function e(t,n){var e;for(e in t)Object.hasOwnProperty.call(t,e)&&n(e)}function i(t,n){return e(n,function(e){t[e]=n[e]}),t}function r(t,n){e(n,function(e){t[e]===void 0&&(t[e]=n[e])})}function o(t,n,e,i,r,o,u){var s,c,h,p=o>t?0:(t-o)/r;for(s in n)n.hasOwnProperty(s)&&(c=u[s],h="function"==typeof c?c:f[c],n[s]=a(e[s],i[s],h,p));return n}function a(t,n,e,i){return t+(n-t)*e(i)}function u(t,n){var i=h.prototype.filter,r=t._filterArgs;e(i,function(e){i[e][n]!==void 0&&i[e][n].apply(t,r)})}function s(t,n,e,i,r,a,s,c,h,f,p){g=n+e+i,y=Math.min(p||d(),g),v=y>=g,M=i-(g-y),t.isPlaying()&&!v?(t._scheduleId=f(t._timeoutHandler,m),u(t,"beforeTween"),n+e>y?o(1,r,a,s,1,1,c):o(y,r,a,s,i,n+e,c),u(t,"afterTween"),h(r,t._attachment,M)):t.isPlaying()&&v&&(h(s,t._attachment,M),t.stop(!0))}function c(t,n){var i={},r=typeof n;return"string"===r||"function"===r?e(t,function(t){i[t]=n}):e(t,function(t){i[t]||(i[t]=n[t]||l)}),i}function h(t,n){this._currentState=t||{},this._configured=!1,this._scheduleFunction=p,n!==void 0&&this.setConfig(n)}var f,p,l="linear",_=500,m=1e3/60,w=Date.now?Date.now:function(){return+new Date},d="undefined"!=typeof SHIFTY_DEBUG_NOW?SHIFTY_DEBUG_NOW:w;p="undefined"!=typeof window?window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||window.mozCancelRequestAnimationFrame&&window.mozRequestAnimationFrame||setTimeout:setTimeout;var g,y,v,M;return h.prototype.tween=function(t){return this._isTweening?this:(void 0===t&&this._configured||this.setConfig(t),this._timestamp=d(),this._start(this.get(),this._attachment),this.resume())},h.prototype.setConfig=function(t){t=t||{},this._configured=!0,this._attachment=t.attachment,this._pausedAtTime=null,this._scheduleId=null,this._delay=t.delay||0,this._start=t.start||n,this._step=t.step||n,this._finish=t.finish||n,this._duration=t.duration||_,this._currentState=i({},t.from)||this.get(),this._originalState=this.get(),this._targetState=i({},t.to)||this.get();var e=this;this._timeoutHandler=function(){s(e,e._timestamp,e._delay,e._duration,e._currentState,e._originalState,e._targetState,e._easing,e._step,e._scheduleFunction)};var o=this._currentState,a=this._targetState;return r(a,o),this._easing=c(o,t.easing||l),this._filterArgs=[o,this._originalState,a,this._easing],u(this,"tweenCreated"),this},h.prototype.get=function(){return i({},this._currentState)},h.prototype.set=function(t){this._currentState=t},h.prototype.pause=function(){return this._pausedAtTime=d(),this._isPaused=!0,this},h.prototype.resume=function(){return this._isPaused&&(this._timestamp+=d()-this._pausedAtTime),this._isPaused=!1,this._isTweening=!0,this._timeoutHandler(),this},h.prototype.seek=function(t){t=Math.max(t,0);var n=d();return 0===this._timestamp+t?this:(this._timestamp=n-t,this.isPlaying()||(this._isTweening=!0,this._isPaused=!1,s(this,this._timestamp,this._delay,this._duration,this._currentState,this._originalState,this._targetState,this._easing,this._step,this._scheduleFunction,n),this.pause()),this)},h.prototype.stop=function(e){return this._isTweening=!1,this._isPaused=!1,this._timeoutHandler=n,(t.cancelAnimationFrame||t.webkitCancelAnimationFrame||t.oCancelAnimationFrame||t.msCancelAnimationFrame||t.mozCancelRequestAnimationFrame||t.clearTimeout)(this._scheduleId),e&&(u(this,"beforeTween"),o(1,this._currentState,this._originalState,this._targetState,1,0,this._easing),u(this,"afterTween"),u(this,"afterTweenEnd"),this._finish.call(this,this._currentState,this._attachment)),this},h.prototype.isPlaying=function(){return this._isTweening&&!this._isPaused},h.prototype.setScheduleFunction=function(t){this._scheduleFunction=t},h.prototype.dispose=function(){var t;for(t in this)this.hasOwnProperty(t)&&delete this[t]},h.prototype.filter={},h.prototype.formula={linear:function(t){return t}},f=h.prototype.formula,i(h,{now:d,each:e,tweenProps:o,tweenProp:a,applyFilter:u,shallowCopy:i,defaults:r,composeEasingObject:c}),"function"==typeof SHIFTY_DEBUG_NOW&&(t.timeoutHandler=s),"object"==typeof exports?module.exports=h:"function"==typeof define&&define.amdDISABLED?define(function(){return h}):t.NGTweenable===void 0&&(t.NGTweenable=h),h}();(function(){n.shallowCopy(n.prototype.formula,{easeInQuad:function(t){return Math.pow(t,2)},easeOutQuad:function(t){return-(Math.pow(t-1,2)-1)},easeInOutQuad:function(t){return 1>(t/=.5)?.5*Math.pow(t,2):-.5*((t-=2)*t-2)},easeInCubic:function(t){return Math.pow(t,3)},easeOutCubic:function(t){return Math.pow(t-1,3)+1},easeInOutCubic:function(t){return 1>(t/=.5)?.5*Math.pow(t,3):.5*(Math.pow(t-2,3)+2)},easeInQuart:function(t){return Math.pow(t,4)},easeOutQuart:function(t){return-(Math.pow(t-1,4)-1)},easeInOutQuart:function(t){return 1>(t/=.5)?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},easeInQuint:function(t){return Math.pow(t,5)},easeOutQuint:function(t){return Math.pow(t-1,5)+1},easeInOutQuint:function(t){return 1>(t/=.5)?.5*Math.pow(t,5):.5*(Math.pow(t-2,5)+2)},easeInSine:function(t){return-Math.cos(t*(Math.PI/2))+1},easeOutSine:function(t){return Math.sin(t*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:-Math.pow(2,-10*t)+1},easeInOutExpo:function(t){return 0===t?0:1===t?1:1>(t/=.5)?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-Math.pow(t-1,2))},easeInOutCirc:function(t){return 1>(t/=.5)?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeOutBounce:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},easeInBack:function(t){var n=1.70158;return t*t*((n+1)*t-n)},easeOutBack:function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},easeInOutBack:function(t){var n=1.70158;return 1>(t/=.5)?.5*t*t*(((n*=1.525)+1)*t-n):.5*((t-=2)*t*(((n*=1.525)+1)*t+n)+2)},elastic:function(t){return-1*Math.pow(4,-8*t)*Math.sin((6*t-1)*2*Math.PI/2)+1},swingFromTo:function(t){var n=1.70158;return 1>(t/=.5)?.5*t*t*(((n*=1.525)+1)*t-n):.5*((t-=2)*t*(((n*=1.525)+1)*t+n)+2)},swingFrom:function(t){var n=1.70158;return t*t*((n+1)*t-n)},swingTo:function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},bounce:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},bouncePast:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?2-(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?2-(7.5625*(t-=2.25/2.75)*t+.9375):2-(7.5625*(t-=2.625/2.75)*t+.984375)},easeFromTo:function(t){return 1>(t/=.5)?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},easeFrom:function(t){return Math.pow(t,4)},easeTo:function(t){return Math.pow(t,.25)}})})(),function(){function t(t,n,e,i,r,o){function a(t){return((l*t+_)*t+m)*t}function u(t){return((w*t+d)*t+g)*t}function s(t){return(3*l*t+2*_)*t+m}function c(t){return 1/(200*t)}function h(t,n){return u(p(t,n))}function f(t){return t>=0?t:0-t}function p(t,n){var e,i,r,o,u,c;for(r=t,c=0;8>c;c++){if(o=a(r)-t,n>f(o))return r;if(u=s(r),1e-6>f(u))break;r-=o/u}if(e=0,i=1,r=t,e>r)return e;if(r>i)return i;for(;i>e;){if(o=a(r),n>f(o-t))return r;t>o?e=r:i=r,r=.5*(i-e)+e}return r}var l=0,_=0,m=0,w=0,d=0,g=0;return m=3*n,_=3*(i-n)-m,l=1-m-_,g=3*e,d=3*(r-e)-g,w=1-g-d,h(t,c(o))}function e(n,e,i,r){return function(o){return t(o,n,e,i,r,1)}}n.setBezierFunction=function(t,i,r,o,a){var u=e(i,r,o,a);return u.displayName=t,u.x1=i,u.y1=r,u.x2=o,u.y2=a,n.prototype.formula[t]=u},n.unsetBezierFunction=function(t){delete n.prototype.formula[t]}}(),function(){function t(t,e,i,r,o,a){return n.tweenProps(r,e,t,i,1,a,o)}var e=new n;e._filterArgs=[],n.interpolate=function(i,r,o,a,u){var s=n.shallowCopy({},i),c=u||0,h=n.composeEasingObject(i,a||"linear");e.set({});var f=e._filterArgs;f.length=0,f[0]=s,f[1]=i,f[2]=r,f[3]=h,n.applyFilter(e,"tweenCreated"),n.applyFilter(e,"beforeTween");var p=t(i,s,r,o,h,c);return n.applyFilter(e,"afterTween"),p}}(),function(t){function n(t,n){var e,i=[],r=t.length;for(e=0;r>e;e++)i.push("_"+n+"_"+e);return i}function e(t){var n=t.match(M);return n?(1===n.length||t[0].match(v))&&n.unshift(""):n=["",""],n.join(O)}function i(n){t.each(n,function(t){var e=n[t];"string"==typeof e&&e.match(S)&&(n[t]=r(e))})}function r(t){return s(S,t,o)}function o(t){var n=a(t);return"rgb("+n[0]+","+n[1]+","+n[2]+")"}function a(t){return t=t.replace(/#/,""),3===t.length&&(t=t.split(""),t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]),b[0]=u(t.substr(0,2)),b[1]=u(t.substr(2,2)),b[2]=u(t.substr(4,2)),b}function u(t){return parseInt(t,16)}function s(t,n,e){var i=n.match(t),r=n.replace(t,O);if(i)for(var o,a=i.length,u=0;a>u;u++)o=i.shift(),r=r.replace(O,e(o));return r}function c(t){return s(T,t,h)}function h(t){for(var n=t.match(F),e=n.length,i=t.match(I)[0],r=0;e>r;r++)i+=parseInt(n[r],10)+",";return i=i.slice(0,-1)+")"}function f(i){var r={};return t.each(i,function(t){var o=i[t];if("string"==typeof o){var a=d(o);r[t]={formatString:e(o),chunkNames:n(a,t)}}}),r}function p(n,e){t.each(e,function(t){for(var i=n[t],r=d(i),o=r.length,a=0;o>a;a++)n[e[t].chunkNames[a]]=+r[a];delete n[t]})}function l(n,e){t.each(e,function(t){var i=n[t],r=_(n,e[t].chunkNames),o=m(r,e[t].chunkNames);i=w(e[t].formatString,o),n[t]=c(i)})}function _(t,n){for(var e,i={},r=n.length,o=0;r>o;o++)e=n[o],i[e]=t[e],delete t[e];return i}function m(t,n){k.length=0;for(var e=n.length,i=0;e>i;i++)k.push(t[n[i]]);return k}function w(t,n){for(var e=t,i=n.length,r=0;i>r;r++)e=e.replace(O,+n[r].toFixed(4));return e}function d(t){return t.match(F)}function g(n,e){t.each(e,function(t){var i,r=e[t],o=r.chunkNames,a=o.length,u=n[t];if("string"==typeof u){var s=u.split(" "),c=s[s.length-1];for(i=0;a>i;i++)n[o[i]]=s[i]||c}else for(i=0;a>i;i++)n[o[i]]=u;delete n[t]})}function y(n,e){t.each(e,function(t){var i=e[t],r=i.chunkNames,o=r.length,a=n[r[0]],u=typeof a;if("string"===u){for(var s="",c=0;o>c;c++)s+=" "+n[r[c]],delete n[r[c]];n[t]=s.substr(1)}else n[t]=a})}var v=/(\d|\-|\.)/,M=/([^\-0-9\.]+)/g,F=/[0-9.\-]+/g,T=RegExp("rgb\\("+F.source+/,\s*/.source+F.source+/,\s*/.source+F.source+"\\)","g"),I=/^.*\(/,S=/#([0-9]|[a-f]){3,6}/gi,O="VAL",b=[],k=[];t.prototype.filter.token={tweenCreated:function(t,n,e){i(t),i(n),i(e),this._tokenData=f(t)},beforeTween:function(t,n,e,i){g(i,this._tokenData),p(t,this._tokenData),p(n,this._tokenData),p(e,this._tokenData)},afterTween:function(t,n,e,i){l(t,this._tokenData),l(n,this._tokenData),l(e,this._tokenData),y(i,this._tokenData)}}}(n)}).call(null);
